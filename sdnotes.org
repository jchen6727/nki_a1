* Useful links
** github
https://github.com/ericaygriffith/A1
** trello
** params
https://docs.google.com/spreadsheets/d/1JoIkf02TWzEXbAA_sfRN8o1VPNi_ai6ZDeBJ5JiRy_o/edit#gid=0 
https://docs.google.com/spreadsheets/d/1rXU6ujzg6TBG59XEFuyE1HTJ6VWM-Jr9XIjMMOxvU1g/edit#gid=972301607
** data
https://drive.google.com/drive/u/0/folders/1InN1hUhVfw20JJ8EuyYell4X3ojgMhGu
** paperpile papers
https://paperpile.com/shared/OfX9NI

* R01 Grant relevant text
** Aim 1 
c.3.1.4 Computational modeling:  We will model flexible cortical oscillations that likely occur in the delta/theta ranges (1-9 Hz) and support auditory information representation, as well as more rigid default oscillations that likely occur at alpha (9-14 Hz) frequencies and higher. This will reveal specific network and cellular properties supporting distinct oscillatory dynamical profiles. For example, rigidity in the alpha oscillations may arise from the strong bidirectional interactions between cortex and thalamus197,198, making it difficult to perturb their properties. We will test this by altering the bidirectional connectivity between cortex and thalamus. We will also stimulate thalamic core/matrix in the model selectively and in combination with pairs of inputs with systematically varied inter-stimulus intervals. We predict that long interstimulus intervals greater than 100 ms will allow the circuitry to adjust its oscillation wavelength to match because sufficient numbers of cortical cells will have time to recover from initially strong stimulation associated with the first input. However, short interstimulus intervals (< 100 ms) will not allow the circuitry sufficient time to adjust its oscillation period, instead only allowing phase resets. This would prohibit the efficient tracking of stimulus structures at these higher rates.

** Aim 2
c.3.2.4 Computational modeling:  We will use our detailed thalamocortical model to investigate mechanisms of phase reset. The model consists of several thalamic nuclei (MGB, pulvinar), each of which contain core and matrix neurons, and thalamic reticular nucleus (TRN). The auditory cortex model contains multiple neuron types (low-threshold and fast-spiking interneurons, pyramidal neurons, spiny stellate neurons) arranged in 6 cortical layers. Neurons are wired using GABAA/GABAB and AMPA/NMDA synapses with appropriate time constants and connection densities based on the literature150,213,214. Importantly, thalamic matrix neurons primarily project to the supragranular cortical layers while thalamic core neurons project to granular and infragranular layers. Our preliminary modeling suggests that thalamic matrix neurons target supragranular dendrite-targeting interneurons, allowing them to contribute to long-lasting inhibition critical for effective phase reset203. We will use our model to test basic mechanisms of phase reset, including the transition from tonic to burst firing, which could be modeled by adjusting the synaptic gain of thalamic matrix neurons. These manipulations would act as a correlate of changes in attention or pharmacological manipulation and will offer predictions on effective neuromodulation strategies for inducing/preventing phase reset through specific pharmacological manipulation of the matrix.


** Aim 3
c.3.3.4 Computational modeling: We will use our model of the thalamocortical system to investigate mechanisms of auditory stream segregation and parsing and their role in auditory information processing. As a correlate of auditory function, we will test auditory decoding fidelity using model LFP/CSD activity to recover auditory signals15  under conditions hypothesized to contribute to more or less effective stream segregation and parsing. We hypothesize that stream segregation and parsing occur through a process of dynamic competition between distinct neuronal ensembles that represent specific auditory information and those that do not, through dynamically regulated inhibition from MGB and pulvinar. To test mechanisms of stream segregation, we will present two competing streams to the MGB neurons with systematically varying gain levels. We predict that the recovered fidelity of the attended signal will depend on the amplitude ratios of stimulus streams and synaptic gains of MGB neurons. We will also test if tonic activation of pulvinar matrix enhances auditory stimulus parsing, enabling better auditory decoding by inserting strong inhibitory periods in A1 activity between repetitive patterns in sound clouds or words in speech218. We will test under which conditions hyperpolarizing pulvinar matrix neurons causes them to burst and reset phase. This reset would presumably activate supragranular interneurons and suppress cortical activation, creating a neural pause corresponding to auditory stimulus stream related activity, improving stimulus encoding/decoding. Depending on the auditory stimulus spectrotemporal characteristics, our model may not accurately encode auditory information. To compensate for this, model synapses will include inhibitory time constants over a broad range of values within physiological limits, enabling variable-pause durations. We will test whether this manipulation will enhance flexible decoding under attention.



** Methods
c.2.4 Computational modeling:  Modeling is performed in the NEURON simulation environment233. Detailed computational modeling methods can be found in our previous publications234-240 and the “Facilities and other resources” section for Brown University.  
* 19Sep19 NKI poster day
** Include mostly data sources for cell types, distribution and connectivity
** Sim diameter=400, densityScale = 0.05
Creating network of 34 cell populations on 4 hosts...
  Number of cells on node 0: 606 
  Number of cells on node 3: 605 
  Done; cell creation time = 8.15 s.
Making connections...
  Number of cells on node 1: 606 
  Number of cells on node 2: 605 
  Number of connections on node 0: 262101 
  Number of synaptic contacts on node 0: 521366 
  Number of connections on node 2: 261122 
  Number of synaptic contacts on node 2: 519362 
  Number of connections on node 1: 262258 
  Number of synaptic contacts on node 1: 521567 
  Number of connections on node 3: 261192 
  Number of synaptic contacts on node 3: 519517 
  Done; cell connection time = 87.65 s.
Adding stims...
  Number of stims on node 1: 1212 
  Number of stims on node 0: 1212 
  Number of stims on node 2: 1210 
  Number of stims on node 3: 1210 
  Done; cell stims creation time = 0.39 s.
Recording 2 traces of 1 types on node 2
Recording 3 traces of 1 types on node 1
Recording 0 traces of 0 types on node 3
Recording 26 traces of 1 types on node 0

Running simulation for 500.0 ms...
  Done; run time = 1747.12 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 60.30 s.

Analyzing...
>>> >>> 

>>> 
  Cells: 2422
  Connections: 1049095 (433.15 per cell)
  Synaptic contacts: 2086656 (861.54 per cell)
  Spikes: 14431 (11.92 Hz)
  Simulated time: 0.5 s; 4 workers
  Run time: 1747.12 s
Saving output as model_output.pkl ... 
Finished saving!
Saving output as model_output.json  ... 
Finished saving!
  Done; saving time = 0.91 s.

- depolarization block



** Sim diameter=400, densityScale = 0.025

Creating network of 34 cell populations on 4 hosts...
  Number of cells on node 0: 301 
  Done; cell creation time = 3.91 s.
  Number of cells on node 1: 301 
  Number of cells on node 2: 301 
  Number of cells on node 3: 301 
Making connections...
  Number of connections on node 2: 64832 
  Number of synaptic contacts on node 2: 128982 
  Number of connections on node 0: 64584 
  Number of synaptic contacts on node 0: 128422 
  Number of connections on node 1: 65322 
  Number of synaptic contacts on node 1: 129939 
  Number of connections on node 3: 64826 
  Number of synaptic contacts on node 3: 129008 
  Done; cell connection time = 14.51 s.
Adding stims...
  Number of stims on node 2: 602 
  Number of stims on node 1: 602 
  Number of stims on node 3: 602 
  Number of stims on node 0: 602 
  Done; cell stims creation time = 0.11 s.
Recording 0 traces of 0 types on node 3
Recording 0 traces of 0 types on node 0
Recording 0 traces of 0 types on node 1
Recording 0 traces of 0 types on node 2

Running simulation for 500.0 ms...
  Done; run time = 747.24 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 10.84 s.

Analyzing...
>>> >>> 

>>> 
  Cells: 1204
  Connections: 260768 (216.58 per cell)
  Synaptic contacts: 518759 (430.86 per cell)
  Spikes: 12939 (21.49 Hz)
  Simulated time: 0.5 s; 4 workers
  Run time: 747.24 s
Saving output as model_output.pkl ... 
Finished saving!
Saving output as model_output.json  ... 
Finished saving!
  Done; saving time = 0.32 s.
Plotting raster...
  Done; plotting time = 8.38 s

Total time = 785.50 s
* 1Oct2019 Preparing SfN poster
** added thalamic pops and conn
** run sim at scale=0.05, size=400um

Creating network of 39 cell populations on 1 hosts...
  Number of cells on node 0: 2518 
  Done; cell creation time = 18.45 s.
Making connections...
  Number of connections on node 0: 231802 
  Number of synaptic contacts on node 0: 420622 
  Done; cell connection time = 83.43 s.
Adding stims...
  Number of stims on node 0: 5036 
  Done; cell stims creation time = 0.58 s.
Recording 31 traces of 1 types on node 0

Running simulation for 500.0 ms...
exp(910.62) out of range, returning exp(700)
  Done; run time = 4276.86 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 13.35 s.

Analyzing...
  Cells: 2518
  Connections: 234320 (93.06 per cell)
  Synaptic contacts: 425658 (169.05 per cell)
  Spikes: 4011 (3.19 Hz)
  Simulated time: 0.5 s; 1 workers
  Run time: 4276.86 s

- raster shows activity and osc in all layers
- many cells show depol block
* 28oct2019 Feedback from Peter on poster
L5 CT
SOM fire antiphase to PV
Thalamus 30% inhibitors local (disinhibit)
TC->L4 cx FF inh Zador lab (which cell types) - wider projection
TC->low L3 as well
TC -> L5 prob not
TC -> L6 science paper
TCM -> L1(sure) 3 (don’t know) - discuss with lady in 2 weeks
Matrix (whole A1) more broadly tuned than core (1-2mm) - can simulate far away region (no core)
A1 = 8mm wide; core only 1mm; matrix all 
Low freq vs high freq A1 circuits - different 
Cx -> thalamus ok
Dendritic spikes - larkum
L1 flatter, L3 more oscillator
Layerwise data  for csd - and spike data but need to sort;  
Mountain sort - py tool
Email asking for firing rates papers 
— supra granular low firing but high gamma (subthres)
* 05nov2019 Issues with conn from sfn
** discrepancy between conn rules and conn matrix
was due to not using plotConn(synOrConn = 'conn') -- was counting eg AMPA+NMDA, so 2x prob
** extremely high probs NGF4->VIP5B and NG5B->VIP4
due to tesiting on very small net, with just 1 or 2 cells in each pop
* 29dec2019 Discuss next steps with same

a1 connectivity looks good

that part mostly done now? next to constrain with data or want to put in auditory signals first?
salvadord 12:02 PM
y mostly done, I think just missing some cell types that erica was working on
salvadord 12:03 PM
could do pulvinar, auditory inputs or constraining
samn 12:03 PM
i like auditory inputs
since that's more rarely done and brings perception into the picture
salvadord 12:03 PM
auditory inputs - me too!
samn 12:04 PM
yeah, she's good with grants
salvadord 12:04 PM
au inputs also allows to compare better to experiments hopefully
samn 12:04 PM
y
same input so can test outputs, etc.
salvadord 12:05 PM
right… though will raise the question of needing A1 tonotopy tuned to different freqs etc
samn 12:05 PM
yeah, can pick a best frequency seen from the recordings to start
salvadord 12:06 PM
sg
could also assume sparse density so representing larger region with ~same num cells
samn 12:06 PM
good idea
* 07jan2020 Playing with Brian Hears
** installed and did intro tuts
https://brian2hears.readthedocs.io/en/stable/introduction.html
https://brian2hears.readthedocs.io/en/stable/brian.html

A common model of cochlear filtering is to apply a bank of gammatone filters, and then half wave rectify and compress it (for example, with a 1/3 power law). This can be achieved in Brian hears as follows (for 3000 channels in the human hearing range from 20 Hz to 20 kHz):

cfmin, cfmax, cfN = 20*Hz, 20*kHz, 3000
cf = erbspace(cfmin, cfmax, cfN)
sound = Sound('test.wav')
gfb = GammatoneFilterbank(sound, cf)
ihc = FunctionFilterbank(gfb, lambda x: clip(x, 0, Inf)**(1.0/3.0))

** need brian2 to generate the spiking output
- extract python code?
- just extract spike times to start with:
In [33]: M.i
Out[33]: <spikemonitor.i: array([2691, 2788, 2813, ..., 1803, 2045, 2183], dtype=int32)>

In [34]: M.t
Out[34]: 
<spikemonitor.t: array([ 0.74829932,  0.79365079,  0.79365079, ..., 99.97732426,
       99.97732426, 99.97732426]) * msecond>
** auditory nerve spiking questions:
- provides direct input to thalamus? or through inferior colliculus? or other?
- how many cells / netstims do we need? 
- what frequency range to cover?
* 27jan2020 Understanding pathway from cochlea to thalamus
** pathway
Cochlea -> superior olivary complex -> inferior colliculus -> thalamus (MGB) (-> A1)

transform sound to spiking activity arriving at MGB
** Ruben auditory brainstem model
https://github.com/rat-h/auditory-brainstem-model/blob/master/mainmodel.cfg - has some conn info between SBC->LSO
https://sites.google.com/site/auditorybsmodel/home
https://github.com/rat-h/auditory-brainstem-model/blob/master/wiki/HOWTO.md

*** Cell types / populations
Cochlea:
- auditory hair cells (AN)
- ventral cochlear nucleus (VCN):
-- spherical bushy cells (SBC); type II and type I-c
-- globular bushy cell (GBC); type I-c

Superior olivary complex:
- medial nuclei of the trapezoid body (MNTB)
- lateral superior olive (LSO)

Note: missing inferior colliculus

** paper on auditory nerve model
https://www.jneurosci.org/content/30/31/10380.long

** Function of areas
*** Auditory nerve
- there are around 30,000 auditory nerve fibres in each of the two auditory nerves. 
- Each fiber is an axon of a spiral ganglion cell that represents a particular frequency of sound, and a particular range of loudness. 
- Information in each nerve fibre is represented by the rate of action potentials as well as the particular timing of individual action potentials. 

*** cochlear nucleus
- The particular physiology and morphology of each cochlear nucleus cell type enhances different aspects of sound information.
- Several tasks are performed in the cochlear nuclei. 
- By distributing acoustic input to multiple types of principal cells, the auditory pathway is subdivided into parallel ascending pathways, which can simultaneously extract different types of information. 
- VCN: The cells of the ventral cochlear nucleus extract information that is carried by the auditory nerve in the timing of firing and in the pattern of activation of the population of auditory nerve fibers. 
- DCN: The cells of the dorsal cochlear nucleus perform a non-linear spectral analysis and place that spectral analysis into the context of the location of the head, ears and shoulders and that separate expected, self-generated spectral cues from more interesting, unexpected spectral cues using igh-level. 

*** Superior olivary complex
- MTO and LSO
-- The medial superior olive (MSO) is a specialized nucleus that is believed to measure the time difference of arrival of sounds between the ears (the interaural time difference or ITD).
-- The lateral superior olive (LSO) is believed to be involved in measuring the difference in sound intensity between the ears (the interaural level difference or ILD).

- MNTB 
-- neurons plays essentials roles in the localization of sound sources and encoding temporal features of complex sounds
-- https://www.ncbi.nlm.nih.gov/pubmed/25873865

*** Inferior colliculus
- Has 3 subdivisions: the central nucleus, the dorsal cortex by which it is surrounded, and an external cortex which is located laterally
- Receives input from: braistem, MGB, A1, basal ganglia, superior colliculus and otherwise; outputs to MGB
- Integrative station and switchboard. 
- Involved in the integration and routing of multi-modal sensory perception, mainly the startle response and vestibulo-ocular reflex. 
- Responsive to specific amplitude modulation frequencies and this might be responsible for detection of pitch. 
- Also related to spatial localization by binaural hearing.
- The receptive fields in inferior colliculus can be seen adapted to handling natural sound transformations.

** email to Sue and Emili
Hi Sue and Emili,
 
As you know we are developing an auditory thalamocortical model with Peter Lakatos. We are trying to figure out what would be an appropriate model to transform an arbitrary sound input signal to the inputs arriving at thalamus (MGB), including processing at cochlea, superior olivary complex and inferior colliculus.
 
We started looking at Brian Hears (http://www.briansimulator.org/docs/hears), which does some cochlea-like filtering, but we are not sure its output can be directly used as input to MGB. We are also looking at this model of auditory brainstem implemented in NEURON, but this might be too detailed and computationally expensive. Ideally, we are looking for some fast phenomenological model that captures the input pathway transformations and outputs spike that can be fed to MGB.
 
Do you have any insights or suggested models ?
 
Thanks!
Salva
** email from Emili
from Emili: “With regards to your model, in our recent paper, we used a peripheral implementation which is relatively up to date, and pretty fast, not sure if is what you are after but perhaps it is useful.
https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1006820”

I checked the model and it’s in Python (compatible with 2 and 3) … and seems to capture more details than Brian Hears

https://github.com/qtabs/moch 

** email from Sue Denham
Sue Denham: “Regarding the peripheral model .. there are many out there .. but to be honest i do not think the processing much beyond the cochlea and small aspects in the cochlear nucleus and IC have been modelled well yet. Emili’s suggestion is probably a good one. It depends though on how realistic you want to be. And of course there are also massive feedback projections which are largely ignored .. good luck :-)”

** Emili's model
https://github.com/qtabs/moch
https://github.com/mrkrd/cochlea
https://github.com/mrkrd/thorns
https://link.springer.com/article/10.1007%2Fs00441-015-2202-z

*** installing cochlea
[error:fatal error: 'numpy/arrayobject.h' file not found; solved by adding path to CFLAGS]
setenv CFLAGS "-I/usr/local/lib/python3.7/site-packages/numpy/core/include/"
pip install cochlea (or git clone and python setup.py install)

** Convergence of cochelar auditory nerve fibers onto MGB (indirect, )
- from  https://sites.google.com/site/auditorybsmodel/home): 

Table 2.

                        lSBC        sSBC        GBS     D-SC

N                      36600        36600       6300    6300    

Converging ANFs, n      2-3        2-3          ~23     10



Table 3.
                        MNTB-PC    LSO-PC

N                       2000-6000  75% of the population

Excitatory  Inputs, n       1      10

- conn: SBC -> LSO and GBC -> LSO
- convergence ANF to LSO cells = 2-3 * 10 = 20-30 or 23 * 10 = 230; assume first, so 25 ANF inputs per LSO cell  


- convergence between LSO cells to MGB cells (Oliv18; chapter 2)
-- Almost all of the ascending projections to the MG arise in the ipsilateral IC with a small contribution from the contralateral IC
-- LSO / inferior colliculus has complex circuitry with multiple layers and several morphologically distinct cell populations 
-- 10-30% of inhibitory projections 

- number of ANFs:
-- human: 30,000
-- cat: 50,000
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3198376/

- similar tuning in macaques as in humans:
-- https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3198376/
* 6Feb2020 Carney model for Auditory nerve fibers (ANF) and Inferior Colliculus (IC)
** email from slava
Hi Everyone,
Thanks for your interest in the 'auditory-brainstem-model' description. I think, it might also be good to check e.g. the Auditory Modeling Toolbox (AMT) and maybe some implementations might be useful for your project. The AMT collection contains many models for different stages of the auditory system ( + description/documentation and references).
http://amtoolbox.sourceforge.net/models.php
>>a low to moderate complexity circuit model 
Regarding the IC stage and (functional) input transmission to higher centers, maybe it would be interesting to check Nelson and Carney (2004) as a first step for your project. This is a phenomenological CN-IC model with the same-frequency inhibition and excitation implementation, which can be stimulated by the AN model. It is better to use filter implementation (Python or Matlab) which is faster than convolution.
https://www.urmc.rochester.edu/labs/carney/publications-code/auditory-models.aspx
Best regards,
Slava
** chat with sam
so I’m gonna check the SOC,IC reduced models he suggested here
3:22
and if makes sense probably used those (maybe in combination with the Cochlea package, if they dont have a cochlea built in)

samn  3:22 PM
ic, sg ... i looked at that page briefly but not at the code it lists
3:24
by cns/sfn will prob be able to compare nhp data and model output under speech input

salvadord  4:37 PM
yes, in theory once I connect the cochlea/SOC/IC, the next step would be to tune the network params to reproduce some physio data… so could start using some data for that

samn  4:44 PM
sg

salvadord  1:01 PM
the model suggested by Slava (not Salva!) transforms .wav file to IC output spikes … so looks perfect, except that it’s in Matlab and C++
image.png 
image.png


1:02
in theory they say works with Octave, so could potentially just call code from netpyne at start, generate spikes and save the to file, and then read from netpyne

samn  1:02 PM
ah, wonder if can convert to py or just use to produce spikes
1:02
if works in octave sg

salvadord  1:02 PM
other option would be to convert to py … right … but that might take more time as code doesnt look simple, and has the C++ code embedded
1:02
ok, I’ll try the octave option for now

samn  1:02 PM
sg
1:02
thx
1:03
want wav files? or just testing first anyway

salvadord  1:03 PM
if find a brave student could be a nice project to convert to py, and useful for others…

samn  1:03 PM
yeah

salvadord  1:03 PM
sure if have experiment wav can share, but not urgent
** links to Matlab code
https://www.urmc.rochester.edu/labs/carney/publications-code/auditory-models.aspx
https://www.urmc.rochester.edu/MediaLibraries/URMCMedia/labs/carney-lab/codes/UR_EAR_v2_1.zip
** Conversion to Octave
- installed Octave 4.4.1 for mac (bundled dmg)
- https://github.com/joyofdata/octave-matlab

- pkg install -forge control
- pkg install -forge signal
- pkg load control
- pkg load signal

- UR_EAR_v2_1.m - doesn't work -- many missing functions, specially for GUI

- extracted code from UR_EAR_v2_1.m; removing all of GUI components
- Used the following models:
-- Which_IC = 2 AN_ModFilt model (Mao et al., 2016)
-- Which_AN = 1 (Zilany et al., 2014)

** Progress but now stuck (chat)
installed Octave and tried code but lots of missing functions, specially for GUI stuff which is all mixed in code


5:22
been working on extracting the essential code (without GUI) and replacing missing funcs etc
5:23
have first stages working now, but now have issue with some of the C code and compiled mex version, which not working in Octave

billl  5:23 PM
octave generally a disaster and think has fallen further and further behind -- in fact i asked about it at the review last week and everyone said fuggedaboutit

salvadord  5:24 PM
will see if can find work around … unfortunately the simple IC model (filter version recommended by Slava) doesnt include the .c code, just the compiled versions, which don’t seem to be recognized by Octave
5:26
octave disaster - I was actually quite impressed with how advanced was since last time I tried … version 4.4 and nice GUI, plus many packages available … but yeah, still not matlab
5:26
I will keep trying to find solution … otherwise guess potentially could use matlab to generate inputs for now, since available at NKI
** installed Matlab - all works
** output of IC is avg firing rate -- how to input in NEURON?
- vec.play stim into NetStim
- eg:
init_amp = 0.0
peak_amp = 0.24
ramp_up = np.linspace(init_amp, peak_amp, simConfig.duration/(simConfig.dt))
t = h.Vector(np.arange(0,simConfig.duration, simConfig.dt))
amp = h.Vector(ramp_up)
for cell in sim.net.cells:
    try:
        amp.play(cell.stims[0]['hObj']._ref_amp, t, True)
    except:

* 18Feb2020 Preparing to tune model
** consolidated all cell params in .json files
including 3d pt morphologies and weightNorm
** select network size
diam 200 um = 12856 cells
diam 300 um = 28897 cells
diam 400 um = 51344 cells 
** feedback from blake on evol param optimization (suggest using delfi; param sensitivity)
Thank you, Salva. Those comments are very helpful!

That sounds like a tough problem for M1. I think with HNN we were lucky that the parameter space for each round was constrained to <8 parameters and we knew the timing was most critical. My thoughts go to what I’ve been experimenting lately with for the initial optimization (“bootstrapping”). Another PhD student and I have been looking at Delfi, which does inference by using neural networks for density estimation. I’m still learning about the choices involved in constructing the neural network, but I feel it’s a promising direction for these types of problems.
https://github.com/mackelab/delfi/

I’ve run Delfi with HNN and the results are interesting. We were able to run 1M simulations because of the shorter runtime with HNN and it gave us a narrow posterior for the input timings, and acceptable ranges for most synaptic strengths. It also correctly identified parameters that have a minimal impact—their posteriors broad were extremely broad. 

Thinking about how to get the most information out of each simulation, training a neural network seems to be a good fit for your problem. Our HNN test with Delfi was really just a sensitivity analysis. We only ran a single round, where the priors were uniform distributions. However, instead of running a single round, I think you’d benefit from fewer simulations, but more rounds. Each of the algorithms implemented in Delfi can run sequential batches (like evolutionary methods), but they also derive value from all previous simulations by using the complete data set for network training. They iteratively update the model in contrast to evolutionary algorithms that are elucidating relationships (successful progeny) from scratch at each round and throwing out the same bad fits over and over.

You may not be looking for an entirely new approach, but just wanted to share this. I’d love to talk more about it.

Best,
** response to blake (explain what we need)
Hi Blake, thanks, this is really interesting.
 
We recently went through the delfi biorxiv paper in our journal club, and were not totally convinced of it's usefulness, particularly due to the number of sims required. But great to hear you tried it and produced useful results.
 
In the M1 model we have a relativey good idea of the params we are happy to optimize: ~10 connectitvity-related params, within boundaries that were not totally constrained by literature. The main concern is what method to use to find the right parameter values, e.g. multiobjective optim vs evolution strategy, what metaparameters, possibly using some method like the latin hypercube to better explore the param space, …. That said this delfi method seems very useful to verify whether we are selecting suitbale parameters and value ranges; and generally to explore param sensitivity, which we are also interested in doing.
 
Do you have time to chat about this some time on Thursday (Feb 27) ?

** response from blake (suggest other method)

Oh yes, I can see that you may not get a lot of additional value from Delfi beyond a sensitivity analysis. The “amortization” feature was most interesting to us—can we train a model on a bunch of simulations and provide users with reasonable parameter guesses.

I’m happy to chat Thursday! I’m open any time before 2:30pm.

Another possible consideration that comes to mind is MLSL, but I don’t know if it is implemented in a parallel version anywhere. Here’s the NLopt version:
https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#mlsl-multi-level-single-linkage

** potential list of parameters to tune
# overall weights gains 
cfg.EEGain = 1.0 
cfg.EIGain = 1.0 
cfg.IEGain = 1.0 
cfg.IIGain = 1.0 

# I->E/I weights gains for each layer (L2/3+4, L5, L6)
cfg.IEweights = [1.0, 1.0, 1.0] 
cfg.IIweights = [1.5, 1.0, 1.0]

# Weight and rate of background inputs to thal
cfg.weightBkg = {'E': 3.5, 'I': 2.0, 'ThalE': 1.0*1e-2, 'ThalI': 1.0*1e-2}  
cfg.rateBkg = {'E': 80, 'I': 80, 'ThalE': 15, 'ThalI': 15}

# weight and prob conn of cochlear+IC inputs to thal
cfg.weightInput = {'ThalE': 0.5, 'ThalI': 0.5}  
cfg.probInput = {'ThalE': 0.25, 'ThalI': 0.25}  

** fitness function
# fitness is exponential that increases with difference between target and population firing rate
# parameter 'width' controls sensitivity 
# parameter 'maxFitness' set the maximum (worst) allowed fitness value
# parameter v['min'] sets minimum value; if rate is below, then fitness becomes maxFitness
# perfect fitness = 0
    fitness = np.mean([min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
                if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.iteritems()])

# for each population can then set 'target' firing rate, 'width' (~sensitivity), and 'min' value e.g.
    pops = {} 
    Etune = {'target': 10, 'width': 5, 'min': 0.5}
    pops['IT2'] = Etune
    pops['IT4'] = Etune
    pops['IT5A'] = Etune 
    pops['IT5B'] = Etune  
    pops['PT5B'] = Etune 
    pops['IT6'] =  Etune
    pops['CT6'] =  Etune

    Itune = {'target': 20, 'width': 15, 'min': 0.25}
    pops['PV2'] = Itune
    pops['SOM2'] = Itune
    pops['PV5A'] = Itune
    pops['SOM5A'] = Itune
    pops['PV5B'] = Itune
    pops['SOM5B'] = Itune
    pops['PV6'] = Itune
    pops['SOM6'] = Itune

** options for optimization method
*** custom evol optim (inspyred)
- using for M1
- requires deciding metaparameters
- seems to sometimes get stuck on local minima (but haven't tested this systematically; or compared to others)

-    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 50,
        'num_elites': 5,
        'mutation_rate': 0.4,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 100,
*** 'evolutionary strategy' evol optim (inspyred)
- used in the past; similar results as custom
*** multiobjective evol optim (inspyred)
- used for single cell
- not integrated into netpyne; but could add
*** multi-level single-linkage (NLopt)
- suggested by blake
- uses NLOpt py package: https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#mlsl-multi-level-single-linkage
- not integrated into netpyne
*** preliminary analysis of param sensitivity/impact (delfi)
- http://www.mackelab.org/delfi/
- used by blake on hnn 
- might be useful to select suitable params and value ranges
- I think could potentially use existing sims to train
*** param space sampling using latin hypercube

- used by Tim Rumbell for single cell optim
- more homogeneous sampling of the param space 

* 23Mar2020 Tuning model
** tune 1st bkg
- agreed with sam should tune first bkg to each cell type: maybe ~1 Hz for E and ~4-5 Hz for I
- add bkg GABAA input - sometimes helps to desynchronize the cells if it's noisy
- add bkg E and I inputs for each cell type
- can do this manually since quick sims
* 4May2020 bkg tuning
** latest update
reduced the target E rates from 2 to 1.5 hz and that gives better results (eg less depol block)
9:07
also when using apical inputs to E, I was thinking the low flat response of PT5B is not necessarily a bad thing (edited) 
9:08
just means it’s kind of balanced in the sense that increasing both E and I proportionally results in the same low firing rate … which is reasonable
9:09
so have two decent options for bkg inputs
9:09
E 40 hz soma, I 40 hz soma — problems: 2 pops have depol block, 1 pop doesn’t fire
E 40 hz apical, I 40 hz basal — problems: 1 pops have depol block, 2 pop doesn’t fire
for either case can just adjust a bit the bkg weights for the 3 problematic pops
9:12
so will do that tomorrow and then submit a param sweep for conn params to see if can find good solution (with cortical + thalamic conn)
** add hand tuned scaling factors
- finetuning for pops not firing or in dep block
- follow from v22_sim3 - apical E 40 hz apical, I 40 hz basal 
 
   ITP4 : 0.001 Hz
   ITS4 : 0.000 Hz
   IT6 - depol
** checked bkg (only long-range) rates in M1 model
  Spikes: 23790 (2.24 Hz)
   IT2 : 40.600 Hz
   SOM2 : 76.400 Hz
   PV2 : 0.000 Hz
   IT4 : 26.600 Hz
   IT5A : 54.600 Hz
   SOM5A : 84.400 Hz
   PV5A : 0.000 Hz
   IT5B : 43.800 Hz
   PT5B : 1.600 Hz
   SOM5B : 63.200 Hz
   PV5B : 0.000 Hz
   IT6 : 30.200 Hz
   CT6 : 18.600 Hz
   SOM6 : 48.200 Hz
   PV6 : 0.000 Hz
   TPO : 2.524 Hz
   TVL : 1.156 Hz
   S1 : 2.541 Hz
   S2 : 2.542 Hz
   cM1 : 1.259 Hz
   M2 : 1.158 Hz
   OC : 2.462 Hz

* CELL TYPES
** Budinger et al 2018
- Budinger 2018 also mentions few stellates in A1 compared to V1 or S1 (in most species), and also few pyramidal
- large, intrinsically bursting, non adapting pyramidal cells (~PT) found in L5A and L5A/B border
- medium size pyramidals, regular spiking and adapting (~IT) found throughout L5A and 5B
- CT cells projecting to thalamus found in both L5 and L6
- (several differences compared to mouse M1)
** Excitatory types
- IT2,	ITP4 (pyramidal),	ITS4 (stellate),	IT5A,	IT5B,	PT5B,	IT6,	CT6
- maybe add star pyramidal: they are present in L3,L4,L6 and have different physiol, different axonal projs, more radial dends, shorter apical dends
- split IT2 and IT3 - since different connection
** Inhibitory types
- NGF1, PV2/3, PV4, PV5A, PV5B, PV6, SOM2/3,	SOM4,	SOM5A,	SOM5B,	VIPL2/3,	VIP4,	VIP5A,	VIP5B,	VIP6
** Allen Brain V1
http://portal.brain-map.org/explore/models/mv1-all-layers

exc frac	inh frac	PV 	SST	5HT3a	Total
0.85	0.15				
0.85	0.15	0.295918367	0.214285714	0.489795918	1
0.85	0.15	0.552380952	0.295238095	0.152380952	1
0.85	0.15	0.485714286	0.428571429	0.085714286	1
0.85	0.15	0.458333333	0.458333333	0.083333333	1
** total number of neurons in A1
1.6 million (https://www.pnas.org/content/107/36/15927)

* CONNECTIVITY
** Budinger et al 2018
- mentions ‘massive thalamic inputs’ target the few pyramidal cells but also interneurons, ‘providing strong FF inhibition’
** Allen Brain mouse V1
- http://portal.brain-map.org/explore/models/mv1-all-layers
- mentions most conn comes from rat S1 (Thomson & Lamy, 2007)
- https://www.dropbox.com/sh/xb7xasih3d8027u/AAAbKXe0Zmk86o3_y1iPVPCLa?dl=0
- I’m thinking this is better option than using mouse M1 since sensory
- they have nice table with all the prob conn valuesand weights, measured as somatic PSP amp (mV), same as we use
- Distance-dependent probabilities

** BBP mouse S1
*** link
https://bbp.epfl.ch/nmc-portal/downloads
*** cell type acronyms
- List of m-types:

DAC	Descending Axon Cell
NGC-DA	Neurogliaform Cell with dense axonal arborization
NGC-SA	Neurogliaform Cell with slender axonal arborization
HAC	Horizontal Axon Cell
LAC	Large Axon Cell
SAC	Small Axon Cell
MC	Martinotti Cell
BTC	Bitufted Cell
DBC	Double Bouquet Cell
BP	Bipolar Cell
NGC	Neurogliaform Cell
LBC	Large Basket Cell
NBC	Nest Basket Cell
SBC	Small Basket Cell 
ChC	Chandelier Cell
PC	Pyramidal Cell
SP	Star Pyramidal Cell
SS	Spiny Stellate Cell
TTPC1	Thick-tufted Pyramidal Cell with a late bifurcating apical tuft
TTPC2	Thick-tufted Pyramidal Cell with an early bifurcating apical tuft
UTPC	Untufted Pyramidal Cell
STPC	Slender-tufted Pyramidal Cell
TPC_L4	Tufted Pyramidal Cell with apical dendrites terminating in layer 4
TPC_L1	Tufted Pyramidal Cell with apical dendrites terminating in layer 1
IPC	Pyramidal Cell with inverted apical-like dendrites
BPC	Pyramidal Cell with bipolar apical-like dendrites

- List of e-types:

cADpyr	continuous Accommodating (Adapting) for pyramidal cells
cAC	continuous Accommodating
bAC	burst Accommodating
cNAC	continuous Non-accommodating
bNAC	burst Non-accommodating
dNAC	delayed Non-accommodating
cSTUT	continuous Stuttering
bSTUT	burst Stuttering
dSTUT	delayed Stuttering
cIR	continuous Irregular
bIR	burst Irregular

*** cell type correspondence
- see https://bbp.epfl.ch/nmc-portal/web/guest/glossary
- Markram et al 2004
- Markram et al 2015
- Tremblay et al 2016

    # set correspondence between A1 pops and BBP S1 pops  
    data['BBP_S1']['pops'] = {
        'NGF1': 'L1_NGC',                                                                                                                              # L1
        'IT2':  'L2_PC',                                              'PV2':  'L23_LBC',   'SOM2': 'L23_MC',  'VIP2': 'L23_BP', 'NGF2':  'L23_NGC', # L2
        'IT3':  'L3_PC',                                              'PV3':  'L23_LBC',   'SOM3': 'L23_MC',  'VIP3': 'L23_BP', 'NGF3':  'L23_NGC', # L3
        'ITP4': 'L4_PC',     'ITS4': 'L4_SS',                         'PV4':  'L4_LBC',    'SOM4': 'L4_MC',   'VIP4': 'L4_BP',  'NGF4':  'L4_NGC',  # L4
        'IT5A': 'L5_UTPC',   'CT5A': 'L6_TPC_L4',                     'PV5A': 'L5_LBC',   'SOM5A': 'L5_MC',  'VIP5A': 'L5_BP',  'NGF5A': 'L5_NGC',  # L5A
        'IT5B': 'L5_UTPC',   'CT5B': 'L6_TPC_L4', 'PT5B': 'L5_TTPC2', 'PV5B': 'L5_LBC',   'SOM5B': 'L5_MC',  'VIP5B': 'L5_BP',  'NGF5B': 'L5_NGC',  # L5B
        'IT6':  'L6_TPC_L1', 'CT6':  'L6_TPC_L4',                     'PV6':  'L6_LBC',    'SOM6': 'L6_MC',   'VIP6': 'L6_BP',  'NGF6':  'L6_NGC'}  # L6

- IT L2,3,4 = PC (=regular pyramidal cell)
- IT5A,5B = UTPC (=thin-tufted)
- PT5B = TTPC2 (=thick-tufted with bifurcation, as our PT cell; other thick-tufted TTPC2 would also probably work)
- CT L5A,5B,6 = TPC_L4 (= CT cell; paper showed CT cells apical only reaches L4; seems they don't have CT cells in L5A,5B)
- IT6 = TPC_L1 (assume this one to differentiate from CT6)
- PV = LBC (=large basket; most abundant PV based on Markram 2004)
- SOM = MC (=martinotti; most abundaant SOM based on Makram 2004)
- VIP = BP (=bipolar cell; based on Tremblay 2015 classification)
- NGF = NGC (=neurogliaform)

*** comparison to Allen
- not distance-dependent
- more cell-type specificity (different exc types from L4,L5,L6 -- ITP,ITS,PT,CT; and 1 more inh types -- VIP)

** E-E 
- Use Allen V1 as base, and then update with any specific A1

*** probability
- L3,4 E -> L3,4 E (Levy & Reyes, 2012)
 
*** weight
- L3,4 E -> L3,4 E (Levy & Reyes, 2012)

** E->I
- Use Allen V1 as base, and then update with any specific A1

- Apicella 2012 (mouse M1)
-- E -> intralaminar I
-- L2/3 E -> L5 LTS (strong)
-- L5 E -> L5 LTS (weak)
-- L5 E -> L5 FS (strong)
-- L2/3 E -> L5 FS (weak)

- Tremblay 2016 (many species):
-- unclear if L2/3 E -> NGF
-- callosal and thalamic matrix -> NGF

- Sohn 2016 (mouse A1)
-- E -> L2/3 VIP (apical+basal)

- Budinger et al 2018 (A1)
-- L2-5 E -> NGF
-- thalamic -> VIP (bipolar)
-- thalamic + cortical -> VIP (bitufted)

- Garcia et al 2015 ()
-- E -> NGF

- Naka 2016 (fig 1,2) (L5):
-- E do not target VIP or NGF (only PV+SOM)

- CONCLUSION:
-- NGF: 
--- L2-5 E inputs
--- thalamic matrix inputs (to L1)
--- thalamic inputs to L2-L5

-- VIP:
--- E -> VIP
--- thalamic -> VIP
** I->E
- currently distance-dependent

- Tremblay 2016:
-- NGF -> local E and I
-- L1 NGF -> L2/3+L5 tuft
-- L2/3 NGF -> L2/3+L5 distal apical
-- L5 NGF -> L5 prox apical

- Naka 2016 (fig 1,2) (L5):
-- L2/3 VIP -> L5 apical trunk (?)
-- NGF -> L5 apical tuft (same as SOM)

- Budinger 2016 (A1):
-- L2 NGF -> L2 E (prox apic); L6 E (tuft)
-- VIP? (not clear which are)

- Pi 2013
-- VIP -> E (very low; 3/42)

- Kato 2017
-- upper SOM -> deeper E strong (graph decay with dist)
 
** I->I
- currently distance-dependant

- Tremblay 2016:
-- L2/3 VIP -> L2/3+L5 SOM
-- L5 VIP -> L5 SOM
-- NGF -> local E and I
-- L1 NGF -> L1 NGF
-- L2/3 NGF -> L2/3 I
-- L5/6 NGF -> L5/6 I
-- L2/3 PV -> L2/3 PV 
-- L5/6 PV -> L5/6 PV 
-- L2/3 PV -> L2/3 I except SOM 
-- L5/6 PV -> L5/6 I except SOM

- Sohn 2016:
-- PV -> L2/3 VIP (soma)
-- SOM -> L2/3 VIP (basal, apical)
-- VIP -> L2/3 VIP (low overall)
-- similar to PV/SOM -> E

- Naka 16 (fig1,2) (L5):
-- all to all (changes in weights)
-- depends on layer and area
-- VIP -> VIP (weak); FS,SOM (strong)
-- SOM -> SOM (weak); FS,VIP (strong)
-- FS -> FS (strong); SOM,VIP (weak)

- Pi 2013
-- VIP -> SOM (strong; 14/18)
-- VIP -> PV (weak; 4/15)

- Overstreet-Wadiche 2015 (mostly CA1)
** Discussion with Sam of I->E/I 
salvadord 9:55 AM
in the original M1 we had I->E/I as intralaminar, with distance-dep probability and fixed weight

for A1 I’ve improved several things:
1) I->E can target deeper layers as well (eg. L2/3 I -> L5 E) since synapsing at apical dends
2) VIP -> E set to very low prob
samn 9:59 AM
#1 very important
so now not all weights are fixed?
salvadord 10:00 AM
3) I -> I adapted probs based on cell type: VIP -> SOM (strong), PV (weak), VIP (very weak); SOM -> FS+VIP (strong); SOM (weak); FS -> FS (strong); SOM+VIP (weak); NGF -> I (medium) (Naka et al 2016;Tremblay, 2016; Sohn, 2016; Pi et al 2013)
samn 10:00 AM
thx, i like the level of detail in the interneuron circuitry...important too
salvadord 10:01 AM
for now weights are fixed but probs are different
samn 10:01 AM
sg
later on will want to vary the gabaa taus
(that's discussed in grant), but don't have to for first draft
salvadord 10:02 AM
note using the same interpretation of weight as in M1 model, ie. somatic PSP amplitude (mV) in response to single cell input
gabaa taus - sounds good … we can have a base model to start with and then improve iteratively
samn 10:03 AM
so that's good since constrained to the exptl lit
somatic PSP vs conductance change since more interested in effect at output?
salvadord 10:05 AM
harder to get conductance values, specially for dendrite syns
this is how implemented in Allen V1 model and Solstez CA1 too
samn 10:05 AM
ic
salvadord 10:06 AM
netpyne then has weightNormalization value that converts ‘weight’ (somatic PSP) to conductance required at each syn
(need to calculate previously for each cell type and store with cellParasm — weightNorm)
samn 10:06 AM
ic, and that's calculated via sim
in a preprocessing step
salvadord 10:07 AM
I have batch netpyne to calcualte for all M1 cell types … will need to adapt for A1 (in future should automate more)

** Discussion with erica


The IPSC values in [9] are in response to optogenetic stim, which I believe activate >1 presyn neurons, so the IPSC value is conflating both conn prob and weight (weight understood as response to single presyn cell, or unitary connection).
For M1 I did use IPSC values as strengths to derive conn probs, i.e. strength =  conn prob x weight. By obtaining weights (unitary conn somatic epsp values) from a different source, I was able to obtain prob conns from the the IPSC values (strengths). 
So, in essence, these values don't represent weights, but the overall conn strength, and so can be used potentially derive the prob conns (by fixing the weight) or the weight (by fixing the prob conn).

salvadord 4:34 PM
in essence as you can see we are missing most values for I->E and I->I so strategy we used before (M1) is to keep more generic and use intralaminar conn with distance-dep prob conn — for A1 I’ve added several more features based on the data we have (see #auditory) but still quite generic

ericaygriffith:speech_balloon: 4:34 PM
I see, okay that is good to know
intralaminar conn w/ distance-dep prob conn -- is there a "generic" source that we use?
salvadord 4:38 PM
many papers describing dist-dep (including some used in excel sheet) … one I cited for M1 is this: https://paperpile.com/app/p/a9dea0e7-7075-0628-958a-8e4f5be45ac5
ericaygriffith:speech_balloon: 4:39 PM
oh I think I see -- you just mean that non-celltype-specific dist-dep conn data is easier to come by than cell-specific? so going to use that as substitute where we don't have cell-specific data?
sry if I'm misunderstanding you!
salvadord 4:42 PM
yeah… so dist-dep is a feature whether we have cell-type specific data or not
the little cell-type specific data we have I’ve tried to incorporate on top of the dist-dep
so e.g. ‘strong’ will be 1.0*exp(-d/L) and ‘weak’ will be 0.35*exp(-d/L)
anyway you can have a look at the excel, conn.py and netParams.py and let me know what you think
** Comparison to BBP and Allen conn
do you have a recommendation based on those differences?
i'm ok with just using allen since has distant dependent. any strong reason to also incorporate BBP?
salvadord 12:58 PM
well there’s 2 diff things to consider: E->E/I and I->E/I
for E-> E/I (currently using Allen), BBP has advantage of differentiating E pops
for I->E/I (currently using our own custom based on papers), both Allen and BBP provide alternatives and show weaker probs from upper I (SOM,NGF) to deeper E — which I had increased since papers showed targeting apical dends
samn 1:00 PM
OK, so I->E/I custom better than either of Allen/BBP for our purposes?
and E->E/I, BBP differentiation of E pops - how much of that is based on cortical layer? macro from Allen might be good enough for our purposes
salvadord 1:03 PM
I->E/I better - maybe, but fact that allen + bbp so different makes me wonder if I’m misinterpreting papers — I’ll recheck and stick to ours if makes sense (or maybe reduce a bit those strong conns to match allen/bbp better)
samn 1:03 PM
sg
thx
& E->E/I BBP - large diffs there too compared to what currently have? (on nki network so google drive blocked...only could look via phone)
I->E/I plan sg anyway, can do 1 step at a time, thx for update
salvadord 1:21 PM
PDF 
A1 conn comparison.pdf
2 MB PDF — Click to view


samn 1:22 PM
thx
salvadord 1:26 PM
btw all conn matrices generated from A1 instantiated model (400 um diameter column; 12k neurons; 25% cell density) so there’s some randomness involved
samn 1:35 PM
for E -> E/I is there a way to adjust to take into account the known/existing subtypes we have from BBP and otherwise leave as is?
one problem then is macro-probabilities could be increased/decreased from what they should be...
salvadord 2:03 PM
adjust E subtypes - yeah I was thinking about that; maybe scale based on BBP
what do u mean by macro-probabilities?
samn 2:03 PM
i mean the probabilities from allen that don't take into account the sub-types
salvadord 2:04 PM
ok y makes sense
samn 2:04 PM
if one population gets more inputs due to bbp then another one might need to get less

** Updating E->E/I conn based on BBP subcelltypes
- Allen does not distinguish E subtypes; and VIP cell type
- Updated VIP, ITS4, CT, PT based on BBP:
*** code in conn.py

# List of pops to update based on BBP ratios of cell subtypes (key = pop to update; value = pop to use as reference)
    updatePopConnUsingBBP = {'VIP2': 'PV2', 'VIP3': 'PV3', 'VIP4': 'PV4', 'VIP5A': 'PV5A', 'VIP5B': 'PV5A', 'VIP6': 'PV6',
                            'ITS4': 'ITP4',
                            'CT5A': 'IT5A',
                            'CT5B': 'IT5B',
                            'PT5B': 'IT5B',
                            'CT6': 'IT6'}
    
    basedOnBBPCT6 = [] #'CT5A', 'CT5B']  # pops based on BBP CT6 (since BBP doesn't have CT5A and CT5B) so treated differently (NOT USED)

    fixVerbose = True  # print info messages
    
    ## update all fix pop (e.g. VIP) by making proportional to ref pop (e.g. PV): e.g. VIP_Allen = (VIP_BBP/PV_BBP) * PV_Allen
    for fixpop, refpop in updatePopConnUsingBBP.items():
        if fixVerbose:
            print('\nUpdating conn probability of pop %s using as reference BBP conn probability ratio of %s:%s ...' % (fixpop, fixpop, refpop))
        
        # E -> fixpop
        for pre in Epops:
            projAllen_ref = '%s-%s' % (data['Allen_V1']['pops'][pre], data['Allen_V1']['pops'][refpop])
            if fixpop in basedOnBBPCT6:
                ## Make CT5A <-> L5A E/I and CT5B <-> L5B E/I == CT6 <-> L6 E/I (so based on local conn) (NOT USED)
                projPre = pre.replace('5A', '6').replace('5B', '6').replace('PT6', 'PT5B')
            else:
                projPre = pre
            projBBP_ref = '%s:%s' % (data['BBP_S1']['pops'][projPre], data['BBP_S1']['pops'][refpop])
            projBBP_fix = '%s:%s' % (data['BBP_S1']['pops'][projPre], data['BBP_S1']['pops'][fixpop])

            # conn probs 
            ref_Allen = data['Allen_V1']['connProb'][projAllen_ref]['A0'] if projAllen_ref in data['Allen_V1']['connProb'] else 0.
            ref_BBP = data['BBP_S1']['connProb'][projBBP_ref]['A0'] if projBBP_ref in data['BBP_S1']['connProb'] else 0.
            fix_BBP = data['BBP_S1']['connProb'][projBBP_fix]['A0'] if projBBP_fix in data['BBP_S1']['connProb'] else 0.
            if ref_BBP > 0. and fix_BBP > 0.:
                if fixVerbose:
                    print(' Prob %s->%s:'%(pre, fixpop), 'ref_BBP: %.2f'%(ref_BBP), 'fix_BBP: %.2f'%(fix_BBP), 'ref_Allen: %.2f'%(ref_Allen), 'fix_Allen: %.2f'%((fix_BBP/ref_BBP) * ref_Allen))
                pmat[pre][fixpop] = (fix_BBP / ref_BBP) * ref_Allen
 
        # fixpop -> E/I
        for post in Epops+Ipops:
            projAllen_ref = '%s-%s' % (data['Allen_V1']['pops'][refpop], data['Allen_V1']['pops'][post])
            if fixpop in basedOnBBPCT6:
                ## Make CT5A <-> L5A E/I and CT5B <-> L5B E/I == CT6 <-> L6 E/I (so based on local conn)  (NOT USED)
                projPost = post.replace('5A', '6').replace('5B', '6').replace('PT6', 'PT5B')
            else:
                projPost = post
            projBBP_ref = '%s:%s' % (data['BBP_S1']['pops'][refpop], data['BBP_S1']['pops'][projPost])
            projBBP_fix = '%s:%s' % (data['BBP_S1']['pops'][fixpop], data['BBP_S1']['pops'][projPost])

            # conn probs 
            ref_Allen = data['Allen_V1']['connProb'][projAllen_ref]['A0'] if projAllen_ref in data['Allen_V1']['connProb'] else 0.
            ref_BBP = data['BBP_S1']['connProb'][projBBP_ref]['A0'] if projBBP_ref in data['BBP_S1']['connProb'] else 0.
            fix_BBP = data['BBP_S1']['connProb'][projBBP_fix]['A0'] if projBBP_fix in data['BBP_S1']['connProb'] else 0.
            if ref_BBP > 0. and fix_BBP > 0.:
                if fixVerbose:
                    print(' Prob %s->%s:'%(fixpop,post), 'ref_BBP: %.2f'%(ref_BBP), 'fix_BBP: %.2f'%(fix_BBP), 'ref_Allen: %.2f'%(ref_Allen), 'fix_Allen: %.2f'%((fix_BBP/ref_BBP) * ref_Allen))
                pmat[fixpop][post] = (fix_BBP / ref_BBP) * ref_Allen

** Updating I->E/I based on Allen
- L2/3 PV and SOM -> L5 Pyr probability is low; <0.05 (based on Jiang et al 2015, Science -- Tolias) -- table S7 and S8 
- CHECK REFS I USED AND WHETHER THEY ARE FROM A1 OR MACAQUE
- REDUCE BASED ON ALLEN?

*** E->I
## Update L2/3 SOM,PV -> deeper E depth-dependent (Kato 2017; Fig 8B); supported by L2/3 PV -> L5 E (Naka 2016, Fig 2)

## Update VIP -> E very low (3/42; Pi et al 2013); but L2/3 VIP -> L5 (Naka 2016, Fig 2)
## make same as SOM but multiply by ration of VIP3->E5 (Pi 2013) / SOM3->E5 (Kato 2017)

*** I -> I
- Allen consistent with 'custom_A1'; with minor diffs:
-- PV -> NGF (0.22) higher than PV -> SOM (0.3); but both lower than PV->PV (0.451) so good
-- SOM -> NGF (0.77), almost as high as SOM -> PV (0.857)
-- interlaminar probs very low (~0.03) but not 0
-- missing VIP (so will use custom_A1 based on existing numbers)

    # VIP uses by default PV weights; need to change the following:
    # VIP -> SOM = strong (but PV -> SOM = weak)    
    # VIP -> PV = weak (but PV -> PV = strong)   
    # VIP -> VIP = weak/veryweak (but PV -> PV = strong) 
** Checking / fixing diffs between empirical and network instantiated conn matrix
- bug in netParams.py (II rules)
- bug in conn.py (avoid double counting BBP adaptation)
** thalamocortical conn 
*** current conn (mostly from Bonj12 and Lakatos comments)
- current TC conn comes from the bazhenov paper (https://www.jneurosci.org/content/32/15/5250.full ; Bonj12) but I don’t see any actual prob or weight values there… @samn do you know how was derived? (edited) 

- only values I see are in a table, which seem to be divergence

*** !Constantinople & Bruno, 2015 (Science); rat S1 (TC->L5/6 pmat+wmat)
- prob of conn between thalamus and cortical layers / cell type:
-- L5 thintufted (IT): 17%
-- L5 thicktufted (PT/CT?): 44%
-- L6: 9% 

- weight (epsp):
-- 0.2 - 1.2 mV
*** !Bruno and Constantinople, 2006; rat S1 (TC->L4)
- L2/3: 0%
- L4: 42.5% / 42.8%

- weight (epsp):
-- 0 - 1. mV

*** !Ji 2016 (mouse A1 MGB -> layers/cell types)
- no distinction core vs matrix (but most input from MGBv=core; same as allen)
- normalized amplitude
- % innervated

% innervated [~= proxy for probability; many presyn axons innervated]
- L1 cell (12/ 22);
- Pyramidal cell (11/15 in L2/3; 18/18 in L4; 12/12 in L5; 8/10 in L6); 
- PV cell (11/14 in L2/3;13/13 in L4; 15/15 in L5; 8/8 in L6); 
- VIP cell (0/17 in L2/3; 6/16 in L4; 0/10 in L5; 0/6 in L6); 
- SOM cell (1/12 in L2/3; 5/14 in L4; 0/10 in L5; 0/6 in L6)


A1  (adjusted amplitude pA [~= strength = prob * weight]):
L1 
L1 22 425 

Pyr 
L2/3 15 129
L4 18 418 
L5 12 195  
L6 10 132  

PV L2/3 14 269 
L4 13 962 
L5 15 426 
L6 8 426 

SOM L4 14 20 

VIP L4 16 24 


*** !check Allen V1 (LGN -> diffrent layers RS/PV; based on Ji2016)
- LGN -> V1
- ~18k units
- no core and matrix

table 2: conns from LGN
celltype    prob    num syns
i1Htr       0.588   10

E2/3        0.789   15
i2/3Pvalb   0.824   15
VIP/SOM     0

E4          1.000   80
i4Pvalb     1.0     75
VIP         0.32
SOM         0.32

E5          1.0     15
i5Pvalb     1.0     20 
VIP/SOM2    0

E6          0.778   15
i6Pvalb     0.818   10
VIP/SOM     0
*** !Cruishcanck 2010 (mouse VB/TRN <-> Barrel cortex L4/5 RS/FS/LTS)
https://www.sciencedirect.com/science/article/pii/S0896627309010435

- strong T -> RS and PV but not SOM
- C -> VB and ITRN; ITRN -> VB (but not -> TRN) i.e. "CT activation produced strong inhibition in VB but not in TRN cells"

- "CT projections outnumber TC projections and that CT synapses provide major input to thalamic neurons"

- Data from fig 6B (avg EPSP amplitudes to optogen stim): 
- L4: 
-- RS: 11 mV
-- FS: 20 mV
-- LTS: 2 mV

- L5: 
-- RS: 15 mV
-- FS: 25 mV
-- LTS: 1 mV

TRN -> TRN: 2.8% prob
TRN -> VB: 8% prob


*** Slater 2019 (A1 L5/6 -> IC; IC->MGB->A1 L5/6; only corticollicular; proportion of L5 vs L6)
*** Viaene 2011 (nothing) 
- checked papers but not useful conn data

*** check BBP S1 (peter's rule)
- VPM based on targeting of fibers (cortical neurons epr fiber)
- found bruno paper

*** Amsalem segev thalamus (nothing on thalamus)
*** Allen new database/papers (anatomical; region level; hard to extract)
- connectivity.brain-map.org ; Harr19
- anatomical - tracing of axons
- thalamic vs auditory regions but not cell-type specific
- general layer info:
-- core -> L4,5,6a
-- matrix -> 1,6a (some 2/3,5)

*** check Elisabetta iavarone (nothing)
- only thalamic cell models
*** Traub thalamocortical model (convergence values; loosely based on data)
- no core vs matrix

INPUTS FROM THALAMOCORTICAL RELAY (TCR) CELLS. 
- Each nRT cell receives input from 40 TCR cells. 

- The following cells each receive input from 10 TCR cells: superficial pyramids (RS, FRB),
superficial basket and axoaxonic cells, tufted pyramids (RS, IB),
nontufted RS pyramids, deep axoaxonic cells. 

- Each of the following cells receives input from 20 TCR cells: spiny stellates,
deep baskets. LTS interneurons do not receive input from TCR
cells (Gibson et al. 1999). 

INPUTS FROM NUCLEUS RETICULARIS (NRT) CELLS. 
- TCR cells each receive input from 30 nRT cells; nRT cells each receive input from 10
nRT cells. 

*** Knox model (oversimplified)
*** Bhattacharya neural mass model (oversimplified conn; eg 1 pyr pop)
- https://www.sciencedirect.com/science/article/abs/pii/S0893608011000839?via%3Dihub
- https://senselab.med.yale.edu/modeldb/ShowModel?model=138970#tabs-1
*** Budinger 2018 (cites other refs; havent' checked)
- Huang and Winer 2000
- Verbny et al. 2006; Lee and Sherman 2008
- Oviedo et al. 2010; Meng et al. 2015
** subcellular conn (dendritic distribution of syns)
*** A1 E/I->E/I
**** Allen V1 (fig 4F)
LGN -> E: dendrites >150um
E -> E2/3,4: soma,dendrites <200um
E -> E5,6: soma,dendrites (all)
E -> I: soma, dendrite (all)
PV -> E,I: soma, dendrites (<50um)
SOM -> E,I: dendries (>50um)
NGF -> E,I: apical dends
NGF2-6 -> E,I: dendrites (50-350um)
***** Note from Allen: didn't get epsps if target only apical -- take into account for model!
Note, however, that during our post-synaptic-potential optimization (see below), we had to change the rules of synaptic placement when L1 was the source onto excitatory cells. Our optimization methodology would create 100 target cells of a specific cell model that receive 1 spike at 0.5 seconds and we would record the generated postsynaptic potential (PSP). The weight would be scaled until we were within 1% of the target PSP. We observed that the when L1 was the source impinging on excitatory cells, the targets sections were so far away that the somatic PSP would reach a maximum and never match the target PSP regardless of how strongly the weight was scaled. This was due to the most distal compartments reaching their maximum membrane deviation that is equal to the reversal potential of the synaptic drive. With these distal compartments being at their maximum, and the attenuation that occurs due to dendritic filtering (recall dendrites in our model are passive), the soma would reach a maximum PSP that did not match our target values.
Thus, to address this issue, we changed the synaptic placement rules for all L1-to-Excitatory neurons so that synapses were placed on dendrites at 50 μm or further from the soma. This is just a highly simplified approximation, but, in terms of reaching closer to the soma than our original rules, it is reasonable since L1 neurogliaform cells are known to bulk release GABA into large volumes and not form well-targeted synapses with post-synaptic cells (Szabadics, Tamás and Soltesz, 2007; Oláh et al., 2009; Tremblay, Lee and Rudy, 2016).
**** Tremblay 2016 (fig 3)
- NGF1 -> E2,3,4: apic_tuft
- NGF2,3,4 -> E2,3,4: apic_trunk
- SOM2,3,4 -> E2,3,4: all_dend (not close to soma)
- PV2,3,4 -> E2,3,4: close to soma 
- SOM5,6 -> E2,3,4: all_dend (not close to soma)

- NGF1 -> E5,6: apic_tuft
- NGF2,3,4 -> E5,6: apic_uppertrunk
- NGF5,6 -> E5,6: apic_lowertrunk
- SOM5,6 -> E5,6: all_dend (not close to soma)
- PV5,6 -> E5,6: close to soma 

*** TC -> soma + non-apical dends
*** TCM -> E apical dends
** Thalamic interneuron conn
*** convert data on %syn but not prob conn
- need total num syns and number of cells on each pop 
*** num syn contacts (SC) in cat MGBv interneurons
A "standard" interneuron possesses about
11,000 SC. Among them, about 5500 SC (1200 of RL
group, 2600 of RS group, 1200 of F group, and 400 of
UT group) are localized on the soma and dendrites of
this cell, while about the same number (5500) of SC are
the contacts distributed on the P-PST, which are the
dendritic terminals of the interneuron. Within the latter
SC population, 1400 SC belong to the RL group, 1000
to the RS, 200 to the F, 2700 to the P, and 200 to the
UT group. 

RL --> inferior colliculus: 1200+1400=2600 (24%)
RS --> axon terminals from A1 neurons: 2600+1000=3600 (33%)
F --> reticular: 1200+200=1400 (13%)
P--> thal interneurons: 2700=2700 (25%)
UT --> unidentified: 400+200=600 (5%)
TOTAL: 10,900

*** num cells in model with diam 200um; total 12958
**** cortex - 12187
NGF1 151
IT2 338
SOM2 5
PV2 13
VIP2 16
NGF2 11
IT3 4461
SOM3 70
PV3 176
VIP3 211
NGF3 150
ITP4 837
ITS4 837
SOM4 24
PV4 93
VIP4 13
NGF4 14
IT5A 359
CT5A 359
SOM5A 43
PV5A 73
VIP5A 10
NGF5A 8
IT5B 471
CT5B 471
PT5B 471
SOM5B 112
PV5B 134
VIP5B 17
NGF5B 24
IT6 1009
CT6 1009
SOM6 63
PV6 84
VIP6 12
NGF6 38
**** thal - 721
TC 116
TCM 155
HTC 38
IRE 155
IREM 155
TI 102
IC 50

*** prob conn
equations:
IC->TI_prob * 50 = 0.24 * TOTAL
CT->TI_prob * (359+471+1009) = 0.33 * TOTAL
RE->TI_prob * (155+155) = 0.13 * TOTAL
TI->TI_prob * 102 = 0.25 * TOTAL 

solving for probs:
IC->TI_prob = 0.24 * TOTAL / 50
CT->TI_prob = 0.33 * TOTAL / (359+471+1009)
RE->TI_prob = 0.13 * TOTAL / (155+155)
TI->TI_prob = 0.25 * TOTAL / 102

assuming, TOTAL1 = 10900 / 5 contacts/syn * 0.5 (only modeling 200um) = 1090
IC->TI_prob = 0.24 * 1090 / 50 = 5.2 (!! increase IC to >= 262)
CT->TI_prob = 0.33 * 1090 / (359+471+1009) =  0.20
RE->TI_prob = 0.13 * 1090 / (155+155) = 0.46
TI->TI_prob = 0.25 * 1090 / 102 = 2.67 (!! increase TI >= 273)

assuming, TOTAL2 = 10900 / 5 contacts/syn * 0.2 (only modeling 200um) = 436:
IC->TI_prob = 0.24 * 436 / 50 = 2.1 (!! increase IC to >=105)
CT->TI_prob = 0.33 * 436 / (359+471+1009) = 0.078
RE->TI_prob = 0.13 * 436 / (155+155) = 0.18
TI->TI_prob = 0.25 * 436 / 102 = 1.06 (!! increase TI to >= 109)

assuming, TOTAL3 = 10900 / 5 contacts/syn * 0.1 (only modeling 200um) = 218:
IC->TI_prob = 0.24 * 218 / 50 = 1.046 (!! increase IC to >= 53); if increase IC to 200 cells --> 0.26
CT->TI_prob = 0.33 * 218 / (359+471+1009) = 0.039
RE->TI_prob = 0.13 * 218 / (155+155) = 0.091
TI->TI_prob = 0.25 * 218 / 102 = 0.534

note eqns hold for single cell:
prob = avg_syns_in_single_post_cell / pre_pop_size = (total_syns / post_pop_size) / pre_pop_size = total_syns / (pre_pop_size * post_pop_size)

*** conclusions
- potentially need to increase ratio of thal cells to conn
- for A1 column of diam 200um we have 12187 cortical cells and only 721 thal cells 
- our current ratio of thal:A1 = 16.9:1
- “Our results suggest an LGN-V1 expansion ratio between 17:1 and 40:1, similar to values reported previously for visual cortex, and other sensory pathways [refs include A1]” (Coen-Cagli et al 2017; F1000Res)

Resulting prob conns with current assumptions:
- IC->TI: 26%
- CT->TI: 4%
- RE->TI: 9%
- TI->TI: 53%

*** calculate TI -> TC
calculate:
TI -> TC based on above num syns TI->TI and following TI outputs:
- TC relay cell: 92%
- Thalamic interneurons: ~8% (7+1) 

TI->TI prob = 0.534 -> divergence = 

- prob = nconn / (preN * postN)
- nconn = 0.534 * (102*102) = 5,556
- conv = nconn / postN = 5,556 / 102 = 55
- div = nconn / preN = 55

TI outputs:
- to TI = 8% = 55
- to TC = 92% = 55 / 0.08 = 688 (=divergence)
- note: TC includes TC+TCM+HTC

- TI->TC nconn = div * 102 = 688 * 102 = 70,176
- TI->TC prob   = nconn / (preN * postN) 
                = 70,176 / (102 * (116+38+155)) 
                = 70,176 / (102*309) 
                = 70,176 / 31,518 
                = 2.22

*** TI -> TC method 2:
- From Serkov 1996:
9100 SC of different groups are distributed on a single
"standard" relay neuron of the MGBv of the cat.
Among them, about 1200, 5200, 1200, 1100, and 400
SC are formed by RL-, RS-, F-, P-, and UT-terminals,
respectively. A "standard" interneuron possesses about
11,000 SC. Among them, about 5500 SC (1200 of RL
group, 2600 of RS group, 1200 of F group, and 400 of
UT group) are localized on the soma and dendrites of
this cell, while about the same number (5500) of SC are
the contacts distributed on the P-PST, which are the
dendritic terminals of the interneuron. Within the latter
SC population, 1400 SC belong to the RL group, 1000
to the RS, 200 to the F, 2700 to the P, and 200 to the
UT group.

RL --> inferior colliculus: 1200 (13%)
RS --> axon terminals from A1 neurons: 5200 (57%)
F --> reticular: 1200 (13%)
P--> thal interneurons: 1100 (12%)
UT --> unidentified: 400 (5%)
TOTAL = 9100 syns

IC->TC_prob * 50 = 0.13 * TOTAL
CT->TC_prob * (359+471+1009) = 0.57 * TOTAL
RE->TC_prob * (155+155) = 0.13 * TOTAL
TI->TC_prob * 102 = 0.12 * TOTAL 

assuming, TOTAL3 = 9100 / 5 contacts/syn * 0.1 (only modeling 200um) = 182:
IC->TC_prob = 0.13 * 182 / 50 = 0.47  if increase IC to 200 cells --> 0.12
CT->TC_prob = 0.57 * 182 / (359+471+1009) = 0.056
RE->TC_prob = 0.13 * 182 / (155+155) = 0.076
TI->TC_prob = 0.12 * 182 / 102 = 0.21

- Calculated values approx match what we already had in model:
RE -> TC = 0.1 (~=0.076)
CT -> TC = 0.1 (~=0.056)
IC -> TC = we made it up (~=0.12) :slightly_smiling_face:


* VERSIONS
** v7 - Added template for connectivity
** v8 - Added cell types
** v9 - Added local connectivity
** v10 - Added thalamic populations from prev model
** v11 - Added thalamic conn from prev model
** v12 - Added CT cells to L5B
** v13 - Added CT cells to L5A
** v14 - Fixed L5A & L5B E cell densities + added CT5A & CT5B to 'Epops'
** v15 - Added cortical and thalamic conn to CT5A and CT5B 
** v16 - Updated multiple cell types
** v17 - Changed NGF -> I prob from strong (1.0) to weak (0.35)
** v18 - Fixed bug in VIP cell morphology
** v19 - Added in 2-compartment thalamic interneuron model 
** v20 - Added TI conn and updated thal pop
** v21 - Added exc+inh bkg inputs specific to each cell type
* SIMS
** v11_manualTune/sim1
- scale 0.05
- x,z = 400um
- tuning params for sfn19 
- reduced bkg inputs weight and rate since before depol block

- results:
-- plotting of cell traces based on (pop,index) not working for multiple cores
-- still some depol block in E and SOM

** v11_manualTune/sim2
- test only bkg inputs
- use single core for now to avoid plotting issue
- voltage traces look better
- suggests maybe reducing local conn weights

** v11_manualTune/sim3
- reduced local conn weights by 50%
- set weightNorm of CT and TC
- reduced bkg from 50 to 40hz

-results:
-- still dep block and weird voltage shapes

** v11_manualTune/sim4
- reduced even more weightNorm (from 0.0025 to 0.001)

- getting better

** v11_manualTune/sim5
- reduced even more weightNorm (from 0.001 to 0.0005)
** v11_manualTune/sim6
- reduced even more weightNorm (from 0.0005 to 0.0001)
** v11_manualTune/sim7
- reduced EE/EI gain to 0.25
** v11_manualTune/sim8
cfg.EEGain = 1.0 * 0.25
cfg.EIGain = 1.0 
cfg.IEGain = 1.0 
cfg.IIGain = 1.0 
cfg.weightBkg = {'E': 0.5*0.025, 'I': 0.5*0.025, 'ThalE': 0.5*0.025, 'ThalI': 0.5*0.025}

- better, got some real oscillations

** v11_manualTune/sim9
cfg.weightBkg = {'E': 0.5*0.01, 'I': 0.5*0.01, 'ThalE': 0.5*0.01, 'ThalI': 0.5*0.01}

** v11_manualTune/sim10
cfg.EEGain = 1.0 * 0.25
cfg.EIGain = 1.0 * 0.5
cfg.IEGain = 1.0 * 1.5
cfg.IIGain = 1.0 * 1.5

worse looking shapes

** v11_manualTune/sim11
sim9 with 0.05 density, recordLFP and 1 sec

Cells: 2518
  Connections: 234320 (93.06 per cell)
  Synaptic contacts: 425658 (169.05 per cell)
  Spikes: 9685 (3.85 Hz)
  Simulated time: 1.0 s; 4 workers
  Run time: 7274.30 s
Saving output as data/v11_manualTune//v11_sim11.pkl ... 
Finished saving!
Saving output as data/v11_manualTune//v11_sim11.json  ... 
Finished saving!
  Done; saving time = 1.59 s.
Total time = 7370.49 s

- all depol block and many traces blank (not sure why)!
- should try to calcualte weightNorm


** v11_batch1-6 - weightNorm for all cells

# ----------------------------------------------------------------------------------------------
# Weight Normalization 
# ----------------------------------------------------------------------------------------------
def weightNorm(pops=[], rule = None, segs = None, allSegs = True, weights=list(np.arange(0.01, 0.2, 0.01)/100.0)):

    # Add params
    from cfg import cfg
    from netParams import netParams

    excludeSegs = ['axon']
    if not segs:
        secs = []
        locs = []
        for secName,sec in netParams.cellParams[rule]['secs'].items():
            if secName not in excludeSegs:
                if allSegs:
                    nseg = sec['geom']['nseg']
                    for iseg in range(nseg):
                        secs.append(secName) 
                        locs.append((iseg+1)*(1.0/(nseg+1)))
                else:
                    secs.append(secName) 
                    locs.append(0.5)

    params = specs.ODict()
    params[('NetStim1', 'pop')] = pops
    params[('NetStim1', 'sec')] = secs
    params[('NetStim1', 'loc')] = locs
    params[('NetStim1', 'weight')] = weights

    groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')] 

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 1.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg[('analysis','plotTraces','include')] = []
    initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
    
    ## turn off components not required
    #initCfg[('analysis', 'plotRaster')] = False
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['addBkgConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = 0
 
    ## set netstim params
    initCfg['addNetStim'] = True
    initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
    initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
    initCfg[('NetStim1', 'start')] = 700
    initCfg[('NetStim1', 'interval')] = 1000
    initCfg[('NetStim1','ynorm')] = [0.0, 1.0]
    initCfg[('NetStim1', 'noise')] = 0
    initCfg[('NetStim1', 'number')] = 1
    initCfg[('NetStim1', 'delay')] = 1
    
    
    b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py', initCfg=initCfg, groupedParams=groupedParams)

    return b

    popsWeightNorm =    {'IT2_A1': ['IT2', 'IT3', 'ITP4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6'],
                        'ITS4_reduced': ['ITS4'],
                        'PV_reduced': ['PV2', 'SOM2'],
                        'VIP_reduced': ['VIP2'],
                        'NGF2': ['NGF2'],
                        'RE_reduced': ['RE', 'TC', 'HTC']}
 
    batchIndex = 1
    for k, v in popsWeightNorm: 
        b = weightNorm(pops=v, rule=k)
        b.batchLabel = 'v11_batch'+str(batchIndex) 
        b.saveFolder = 'data/'+b.batchLabel
        b.method = 'grid'  # evol
        setRunCfg(b, 'mpi_bulletin')
        b.run()  # run batch
        batchIndex += 1


    then run analysis/wscale.py

** v11_batch7 - EI balance
def EIbalance():
    params = specs.ODict()

    params['EEGain'] = [0.5, 1.0, 1.5] 
    params['EIGain'] = [0.5, 1.0, 1.5] 
    params['IEGain'] = [0.5, 1.0, 1.5] 
    params['IIGain'] = [0.5, 1.0, 1.5]
    params[('weightBkg', 'E')] = [2.0, 3.0]
    params[('weightBkg', 'I')] = [2.0, 3.0]
    
    groupedParams =  []

    # initial config
    initCfg = {}
    initCfg['duration'] = 1.0 * 1e3
    initCfg['scaleDensity'] = 0.05
    
    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    return b

*** results
reasonable rates for most pops (no osc):
- 10 00 10
- 11 01 10
- 12 02 10
- 22 02 11
- 22 00 10 - slow osc
** v11_batch8 - weightNorm for thalamic cells after fixing
*** note on version
this should have been v15, not v11
*** code
def weightNorm(pops=[], rule = None, segs = None, allSegs = True, weights=list(np.arange(0.01, 0.2, 0.01)/100.0)):

    # Add params
    from cfg_cell import cfg
    from netParams_cell import netParams

    excludeSegs = ['axon']
    if not segs:
        secs = []
        locs = []
        for secName,sec in netParams.cellParams[rule]['secs'].items():
            if secName not in excludeSegs:
                if allSegs:
                    nseg = sec['geom']['nseg']
                    for iseg in range(nseg):
                        secs.append(secName) 
                        locs.append((iseg+1)*(1.0/(nseg+1)))
                else:
                    secs.append(secName) 
                    locs.append(0.5)

    params = specs.ODict()
    params[('NetStim1', 'pop')] = pops
    params[('NetStim1', 'sec')] = secs
    params[('NetStim1', 'loc')] = locs
    params[('NetStim1', 'weight')] = weights

    groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')] 

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 1.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg['removeWeightNorm'] = True
    initCfg[('analysis','plotTraces','include')] = []
    initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
    
    ## turn off components not required
    #initCfg[('analysis', 'plotRaster')] = False
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['addBkgConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = 0
 
    ## set netstim params
    initCfg['addNetStim'] = True
    initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
    initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
    initCfg[('NetStim1', 'start')] = 700
    initCfg[('NetStim1', 'interval')] = 1000
    initCfg[('NetStim1','ynorm')] = [0.0, 2.0]
    initCfg[('NetStim1', 'noise')] = 0
    initCfg[('NetStim1', 'number')] = 1
    initCfg[('NetStim1', 'delay')] = 1
    
    
    b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py', initCfg=initCfg, groupedParams=groupedParams)
*** results
generated new weightNorm pkl files
now values are reasonable -- not negative as before

** Comparing conn
update conn.py with Allen V1 vs BBP S1 vs custom A1 conn options

run sim at 0.25 scale

allpops = ['NGF1', 'IT2', 'PV2', 'SOM2', 'VIP2', 'NGF2', 'IT3', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'ITP4', 'ITS4', 'PV4', 'SOM4', 'VIP4', 'NGF4', 'IT5A', 'CT5A', 'PV5A', 'SOM5A', 'VIP5A', 'NGF5A', 'IT5B', 'PT5B', 'CT5B', 'PV5B', 'SOM5B', 'VIP5B', 'NGF5B', 'IT6', 'CT6', 'PV6', 'SOM6', 'VIP6', 'NGF6']

sim.analysis.plotConn(includePre=allpops, includePost=allpops, feature='probability', showFig=0, saveFig='conn/E->EI_Allen_V1_prob_0.25.png' , saveData='conn/E->EI_Allen_V1_prob_0.25.pkl')

sim.analysis.plotConn(includePre=allpops, includePost=allpops, feature='probability', showFig=0, saveFig='conn/E->EI_BBP_S1_prob_0.25.png' , saveData='conn/E->EI_BBP_S1_prob_0.25.pkl')

sim.analysis.plotConn(includePre=allpops, includePost=allpops, feature='probability', synOrConn='conn', showFig=0, saveFig='conn/EI->EI_Allen_custom_prob_0.25_fixed.png' , saveData='conn/EI->EI_Allen_custom_prob_0.25_fixed.pkl')
** v16_batch1 - Small parameter on full net 200x200 um (12k cells); to get baseline
*** code
def custom():
    params = specs.ODict()

    params[('weightBkg', 'E')] = [1.0] #[0.1, 0.5, 1.0]
    params[('weightBkg', 'I')] = [1.0] #[0.1, 0.5, 1.0]
    params[('weightBkg', 'ThalE')] = [1.0] #[0.1, 0.5, 1.0]
    params[('weightBkg', 'ThalI')] = [1.0] #[0.1, 0.5, 1.0]
    
    params[('weightInput', 'ThalE')] = [0.0, 1.0] #[0.0, 0.5, 1.0]
    params[('weightInput', 'ThalI')] = [0.0, 1.0] # [0.0, 0.5, 1.0]
    
    groupedParams = []

    # initial config
    initCfg = {}
    initCfg['duration'] = 2.0*1e3
    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    return b 

*** memory error 
slurmstepd: error: Detected 700 oom-kill event(s) in step 5304.batch cgroup. Some of your processes may have been killed by the cgroup out-of-memory handler.
*** try running on 2*96 cores
memory error
*** try running on 4*96 cores
memory error
*** try running 200um (12k cells) on 4*96 cores
worked but subconn bug
*** fixed subconn and added weightNorm
*** tried running 250um (20k cells) on 4*96 cores
memory error
*** tried running 250um (20k cells) on 8*96 cores
memory error
*** running 200um (12k cells) on 4*96 cores - results ok
- ITS4 really high 250hz
- ngf pops firing weirdly

*** if not try highmem-96
*** if not try smaller net
** v16_batch2 - Small parameter on 200x200 um (12k cells); to get baseline; after fixing bursting
*** fixed bugs
- ITS4 v_init
- weighNorm of multiple cell types; including NGF with wrong filename
*** tuned params
- increased bkg weights * 5
- reduced ITS4 weightNorm * 5
** v20_batch1 - Added TI; testing only bkg and with conn
*** notes
- failed in g1 -- saturated with params?
- rerunning on g2 (non-preempt)
*** code
def custom():
    params = specs.ODict()

    # bkg inputs
    factor = 5
    
    params['addConn'] = [0, 1]

    params[('weightBkg', 'E')] = [0.5*factor]
    params[('weightBkg', 'I')] = [0.5*factor]
    params[('weightBkg', 'ThalE')] = [0.5*factor]
    params[('weightBkg', 'ThalI')] = [0.5 * factor]

    # params[('rateBkg', 'E')] = [40] #[20, 60]  
    # params[('rateBkg', 'I')] = [40] #
    # params[('rateBkg', 'ThalE')] = [40] #
    # params[('rateBkg', 'ThalI')] = [40] #

    # auditory inputs (cochlea+IC) to thalamus (remove for tuning??)
    # params[('weightInput', 'ThalE')] = [0.5] # [0.25,  0.75] # 0.5 somatic PSP mV 
    # params[('weightInput', 'ThalI')] = [0.5] # [0.25,  0.75] # 0.5 somatic PSP mV 
    # params[('probInput', 'ThalE')] = [0.0] # [0.1, 0.4] # 0.25 probability of conn  
    # params[('probInput', 'ThalI')] = [0.0] # [0.1, 0.4] # 0.25 probability of conn  

    # # conn gains
    # params['EEGain'] = [1.0] #[0.5, 1.5] 
    # params['EIGain'] = [1.0] 
    # params['IEGain'] = [1.0] 
    # params['IIGain'] = [1.0] 

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn '] = False  # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    return b

*** results
**** only bkg
Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 31237 (1.59 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   SOM2 : 13.400 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.688 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.000 Hz
   SOM3 : 12.229 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.611 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.000 Hz
   ITS4 : 17.613 Hz
   SOM4 : 13.125 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.231 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.000 Hz
   CT5A : 0.000 Hz
   SOM5A : 13.047 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.600 Hz
   NGF5A : 0.000 Hz
   IT5B : 0.000 Hz
   CT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5B : 13.473 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.941 Hz
   NGF5B : 0.000 Hz
   IT6 : 0.012 Hz
   CT6 : 0.000 Hz
   SOM6 : 13.159 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.583 Hz
   NGF6 : 0.000 Hz
   TC : 0.207 Hz
   TCM : 0.077 Hz
   HTC : 0.158 Hz
   IRE : 5.665 Hz
   IREM : 6.000 Hz
   TI : 2.029 Hz
   IC : 14.725 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 85.57 s
Saving output as data/v20_batch1/v20_batch1_0_0_0_0_0.json  ... 
Finished saving!
  Done; saving time = 1.75 s.
Plotting raster...
Plotting recorded cell traces ... trace
  Done; plotting time = 22.17 s
Total time = 202.84 s
**** with bkg+conn
Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 445787 (22.67 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.000 Hz
   VIP2 : 173.125 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.000 Hz
   SOM3 : 0.000 Hz
   PV3 : 0.000 Hz
   VIP3 : 174.678 Hz
   NGF3 : 13.647 Hz
   ITP4 : 0.000 Hz
   ITS4 : 265.471 Hz
   SOM4 : 0.000 Hz
   PV4 : 0.000 Hz
   VIP4 : 93.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.000 Hz
   CT5A : 0.000 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   VIP5A : 154.800 Hz
   NGF5A : 468.000 Hz
   IT5B : 0.000 Hz
   CT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5B : 0.000 Hz
   PV5B : 0.000 Hz
   VIP5B : 157.471 Hz
   NGF5B : 487.375 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
   SOM6 : 7.905 Hz
   PV6 : 1.440 Hz
   VIP6 : 10.083 Hz
   NGF6 : 0.000 Hz
   TC : 0.043 Hz
   TCM : 0.510 Hz
   HTC : 0.026 Hz
   IRE : 6.826 Hz
   IREM : 6.581 Hz
   TI : 1.863 Hz
   IC : 14.480 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 785.08 s
Saving output as data/v20_batch1/v20_batch1_1_0_0_0_0.json  ... 
Finished saving!
  Done; saving time = 3.98 s.
Plotting raster...
Plotting recorded cell traces ... trace
  Done; plotting time = 202.85 s
Total time = 1798.94 s
**** conclusions
looks like generally need more bkg
and there might be some issue with ITS4 + VIP + NGF conn … I’ll check
good thing is was pretty fast to run … on 96 cores took 3 min for only bkg, and 30 min for bkg+conn
** v21_batch1 - Evol optim full net; conn params
*** code
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.75, 1.25]
    params['EIGain'] = [0.75, 1.25]

    params[('IEweights', 0)] = [0.75, 1.25]
    params[('IEweights', 1)] = [0.75, 1.25]
    params[('IEweights', 2)] = [0.75, 1.25]

    params[('IIweights', 0)] = [0.75, 1.25]
    params[('IIweights', 1)] = [0.75, 1.25]
    params[('IIweights', 2)] = [0.75, 1.25]
    
    params['thalamoCorticalGain'] = [0.75, 1.25]  
    params['intraThalamicGain'] = [0.75, 1.25] 
    params['corticoThalamicGain'] = [0.75, 1.25]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 5, 'min': 0.5}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 15, 'min': 0.25}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        popFitness = [min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
                if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.items()]
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f'%(p, simData['popRates'][p], popFitness[i]) for i,p in enumerate(pops)])
        print('  '+popInfo)
        return fitness
    
    #from IPython import embed; embed()

    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    # Set evol alg configuration
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 100,
        'num_elites': 2,
        'mutation_rate': 0.5,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 200,
        'time_sleep': 300, # 5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 12, # (5h20) max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000, # set fitness value in case simulation time is over
        'scancelUser': 'ext_salvadordura_gmail_com'
    }

    return b
*** results
- 10 generations
- pops always 0 Hz (14/42): IT2, IT3, ITP4, NGF4, PT5B, CT6, PV2, PV3, PV4, PV6, SOM2, SOM3, SOM4 
- pops always too high >200Hz (3/42): ITS4, NGF5A, NGF5B 
- pops sometimes too high >100Hz (6/42): NGF2, NGF3, VIP2, VIP3, VIP5A, VIP5B

cfg.weightBkg = {'IT': 12.0, 'ITS4': 0.7, 'PT': 15.0, 'CT': 14.0,
                'PV': 28.0, 'SOM': 5.0, 'NGF': 80.0, 'VIP': 9.0,
                'TC': 1.8, 'HTC': 1.55, 'RE': 9.0, 'TI': 3.6}
** v21_batch2 - Param sweep with 5 conn params
*** results
raw results - https://console.cloud.google.com/storage/browser/salvadord_data/v21_batch2/?forceOnBucketsSortingFiltering=false&organizationId=728762063943&project=ecas-2019

firing rate as a func of 4 conn params for each of the 41 pops: https://drive.google.com/open?id=1lZQe3YjX2lGCQsLF_lzc3_FKqTImK-sg

so problematic ones are IT2, IT3 and ITP4 since 0 in most, except a couple with 0.00075 Hz
the trend suggests need to lower more EEGain and increase IIGain
also noticed the IEGain param is not doing anything, so maybe a bug… I’ll check
** v21_batch3 - Param sweep 6 conn params; adjusted EEGain and IIGain; fixed bug IEGain

*** code
params = specs.ODict()

    # bkg inputs
    
    #params['addConn'] = [0, 1]

    params['EEGain'] = [0.25, 0.5, 1.0, 1.5] #[0.5, 1.5] 
    params['EIGain'] = [0.5, 1.0, 1.5] 
    params['IEGain'] = [0.5, 1.0, 1.5] 
    params['IIGain'] = [0.5, 1.0, 1.5, 2.0]
    params['thalamoCorticalGain'] = [0.5, 1.0, 1.5]  #2.5
    #params['intraThalamicGain'] = [0.5, 1.0, 1.5] #0.5
    params['corticoThalamicGain'] = [0.5, 1.0, 1.5]



    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn '] = False  # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
*** results

- unfortunately no param combination yet that gives decent firing rates in all… 
- the problematic ones still IT2, IT3 and ITP4 (upper layer ITs), with close to 0hz rates 
— I had similar issue with M1 and fixed by tuning gains separate for upper vs lower layers, so will try that next
- there is one param combination >0, but only ~0.1 hz
- 0.01 hz in the case of ITP4

- NGF2-6 too high - also possibly and issue; could be affecting E spiking
- could be result of higher background? 
-- cfg.weightBkg = {'IT': 12.0, 'ITS4': 0.7, 'PT': 15.0, 'CT': 14.0,
                'PV': 28.0, 'SOM': 5.0, 'NGF': 80.0, 'VIP': 9.0,
                'TC': 1.8, 'HTC': 1.55, 'RE': 9.0, 'TI': 3.6}
-- enhanced sensitivity 
-- maybe tuned based on L1, but L2-6 different, more conn inputs

things to try:
-- tune NGF L2-6 differently
-- tune weights of upper IT separately 
-- VIP 
** v21_tune - adjusting bkg weights
- run for 10 sec instead of 1 -- better stats; avoids depending on initial 500ms
- included all IT cells since different dend lengths
- included all NGF cells to see variability
- v21_tune8:
   NGF1 : 6.100 Hz
   IT2 : 0.000 Hz
   SOM2 : 8.900 Hz
   PV2 : 4.900 Hz
   VIP2 : 9.100 Hz
   NGF2 : 8.300 Hz
   IT3 : 0.000 Hz
   NGF3 : 7.000 Hz
   ITP4 : 7.800 Hz
   ITS4 : 3.000 Hz
   NGF4 : 8.500 Hz
   NGF5A : 6.600 Hz
   PT5B : 0.700 Hz
   NGF5B : 7.400 Hz
   IT6 : 0.200 Hz
   CT6 : 0.700 Hz
   NGF6 : 8.900 Hz
   TC : 22.100 Hz
   HTC : 19.900 Hz
   IRE : 4.400 Hz
   TI : 12.600 Hz
- clearly some fixes required:
-- reduce NGF a bit (80->60)
-- increase IT (except ITP4 low) (12->20)
-- reduce TC (1.8->1.5)
-- reduce HTC (1.55->1.4)
-- reduce TI (3.6->3)

- v56_tune10
-   NGF1 : 0.500 Hz
   NGF1 : 0.500 Hz
   IT2 : 2.300 Hz
   SOM2 : 8.900 Hz
   PV2 : 4.900 Hz
   VIP2 : 9.100 Hz
   NGF2 : 0.700 Hz
   IT3 : 3.300 Hz
   NGF3 : 0.500 Hz
   ITP4 : 14.200 Hz (dep block)
   ITS4 : 3.000 Hz
   NGF4 : 1.100 Hz
   IT5A : 0.800 Hz (dep block)
   NGF5A : 0.300 Hz
   IT5B : 0.400 Hz (dep block)
   PT5B : 1.100 Hz
   NGF5B : 1.300 Hz
   IT6 : 1.500 Hz (dep block)
   CT6 : 1.700 Hz (dep block)
   NGF6 : 1.400 Hz
   TC : 19.300 Hz
   HTC : 18.400 Hz
   IRE : 5.500 Hz
   TI : 6.300 Hz
- changes:
-- IT down (20->16)
-- NGF up a bit (60->65)
-- reduce TC (1.5 -> 1)
-- reduce HTC  (1.55 -> 1)

- v56_tune11
   NGF1 : 1.500 Hz
   IT2 : 0.400 Hz
   SOM2 : 8.900 Hz
   PV2 : 4.900 Hz
   VIP2 : 9.100 Hz
   NGF2 : 2.300 Hz
   IT3 : 0.800 Hz
   NGF3 : 1.800 Hz
   ITP4 : 14.600 Hz (Dep block)
   ITS4 : 3.000 Hz
   NGF4 : 2.400 Hz
   IT5A : 0.200 Hz (dep block)
   NGF5A : 1.100 Hz
   IT5B : 0.200 Hz
   PT5B : 1.100 Hz
   NGF5B : 2.300 Hz
   IT6 : 0.500 Hz (dep block)
   CT6 : 1.700 Hz (dep block)
   NGF6 : 3.000 Hz
   TC : 17.000 Hz
   HTC : 14.100 Hz
   IRE : 5.500 Hz
   TI : 6.300 Hz

- tune automatically for each cell type
** v22_batch1 - bkg weights for all pops (E+I 40 hz)
*** code
def bkgWeights(pops=[], weights=list(range(50))):

    params = specs.ODict()
    params['singlePop'] = pops
    params['weightBkg'] = weights

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 10.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg['singlePopForNetstim'] = True
    initCfg['removeWeightNorm'] = False
    initCfg[('analysis','plotTraces','include')] = [0]
    initCfg[('analysis','plotTraces','timeRange')] = [0, 3000]
    initCfg[('analysis', 'plotRaster')] = False

    ## turn off components not required
    initCfg['addBkgConn'] = True
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = False
    initCfg['addNetStim'] = False
 

    b = Batch(params=params, netParamsFile='netParams_bkg.py', cfgFile='cfg_cell.py', initCfg=initCfg)

    return b
*** results
Calculating bkg weights for each pop ...
Bkg weight to get 2.0 Hz in pop IT2 = 19.5
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 2.0 Hz in pop IT3 = 18.1
Bkg weight to get 2.0 Hz in pop ITP4 = 9.4
Bkg weight to get 2.0 Hz in pop ITS4 = 0.2
Bkg weight to get 2.0 Hz in pop IT5A = 29.3
Bkg weight to get 2.0 Hz in pop CT5A = 15.8
Bkg weight to get 2.0 Hz in pop IT5B = 27.5
Bkg weight to get 2.0 Hz in pop PT5B = 17.2
Bkg weight to get 2.0 Hz in pop CT5B = 15.8
Bkg weight to get 2.0 Hz in pop IT6 = 19.5
Bkg weight to get 2.0 Hz in pop CT6 = 15.8
Bkg weight to get 2.0 Hz in pop TC = 0.4
Bkg weight to get 2.0 Hz in pop HTC = 0.5
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2


** v22_batch2 - bkg weights for all pops (only E 40hz)
*** results
** v22_batch3 - bkg weights for all pops (E 20hz apicdend, I 40 Hz perisom)
*** results
Calculating bkg weights for each pop ...
Bkg weight to get 2.0 Hz in pop IT2 = 22.0
Bkg weight to get 4.0 Hz in pop PV2 = 44.3
Bkg weight to get 4.0 Hz in pop SOM2 = 7.8
Bkg weight to get 4.0 Hz in pop VIP2 = 14.8
Bkg weight to get 4.0 Hz in pop NGF2 = 101.0
Bkg weight to get 2.0 Hz in pop IT3 = 11.6
Bkg weight to get 2.0 Hz in pop ITP4 = 5.4
Bkg weight to get 2.0 Hz in pop ITS4 = 1.5
Bkg weight to get 2.0 Hz in pop IT5A = 2.2
Bkg weight to get 2.0 Hz in pop CT5A = 7.4
Bkg weight to get 2.0 Hz in pop IT5B = 29.9
Bkg weight to get 2.0 Hz in pop PT5B = inf
Bkg weight to get 2.0 Hz in pop CT5B = 7.4
Bkg weight to get 2.0 Hz in pop IT6 = 6.1
Bkg weight to get 2.0 Hz in pop CT6 = 7.4
Bkg weight to get 2.0 Hz in pop TC = 53.3
Bkg weight to get 2.0 Hz in pop HTC = -64.5
Bkg weight to get 4.0 Hz in pop IRE = 1.5
Bkg weight to get 4.0 Hz in pop TI = 5.3
** v22_batch4 - bkg weights for all pops (E 20hz apicdend 2*weight, I 40 Hz perisom)
Bkg weight to get 2.0 Hz in pop IT2 = 9.0
Bkg weight to get 4.0 Hz in pop PV2 = 19.7
Bkg weight to get 4.0 Hz in pop SOM2 = 2.9
Bkg weight to get 4.0 Hz in pop VIP2 = 5.5
Bkg weight to get 4.0 Hz in pop NGF2 = 42.2
Bkg weight to get 2.0 Hz in pop IT3 = 5.4
Bkg weight to get 2.0 Hz in pop ITP4 = 19.8
Bkg weight to get 2.0 Hz in pop ITS4 = 0.3
Bkg weight to get 2.0 Hz in pop IT5A = 20.4
Bkg weight to get 2.0 Hz in pop CT5A = 3.2
Bkg weight to get 2.0 Hz in pop IT5B = 27.8
Bkg weight to get 2.0 Hz in pop PT5B = 24.5
Bkg weight to get 2.0 Hz in pop CT5B = 3.2
Bkg weight to get 2.0 Hz in pop IT6 = 6.3
Bkg weight to get 2.0 Hz in pop CT6 = 3.2
Bkg weight to get 2.0 Hz in pop TC = -9.3
Bkg weight to get 2.0 Hz in pop HTC = -8.8
Bkg weight to get 4.0 Hz in pop IRE = -0.1
Bkg weight to get 4.0 Hz in pop TI = 2.2
** v22_batch5 - bkg weights for all pops (E 40hz apicdend, I 40 Hz perisom 2*weight)
Bkg weight to get 2.0 Hz in pop IT2 = 25.0
Bkg weight to get 4.0 Hz in pop PV2 = 32.4
Bkg weight to get 4.0 Hz in pop SOM2 = 6.9
Bkg weight to get 4.0 Hz in pop VIP2 = 12.6
Bkg weight to get 4.0 Hz in pop NGF2 = 89.0
Bkg weight to get 2.0 Hz in pop IT3 = 8.6
Bkg weight to get 2.0 Hz in pop ITP4 = 3.3
Bkg weight to get 2.0 Hz in pop ITS4 = 1.4
Bkg weight to get 2.0 Hz in pop IT5A = 32.1
Bkg weight to get 2.0 Hz in pop CT5A = 5.1
Bkg weight to get 2.0 Hz in pop IT5B = 42.7
Bkg weight to get 2.0 Hz in pop PT5B = -inf
Bkg weight to get 2.0 Hz in pop CT5B = 5.1
Bkg weight to get 2.0 Hz in pop IT6 = 12.7
Bkg weight to get 2.0 Hz in pop CT6 = 5.1
Bkg weight to get 2.0 Hz in pop TC = -inf
Bkg weight to get 2.0 Hz in pop HTC = -54.5
Bkg weight to get 4.0 Hz in pop IRE = 6.5
Bkg weight to get 4.0 Hz in pop TI = 53.0
** v22_batch6- bkg weights for all pops (E 40hz apicdend, I 40 Hz perisom)

Bkg weight to get 2.0 Hz in pop IT2 = 19.0
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 2.0 Hz in pop IT3 = 6.4
Bkg weight to get 2.0 Hz in pop ITP4 = 2.2
Bkg weight to get 2.0 Hz in pop ITS4 = 0.2
Bkg weight to get 2.0 Hz in pop IT5A = 21.0
Bkg weight to get 2.0 Hz in pop CT5A = 4.2
Bkg weight to get 2.0 Hz in pop IT5B = 27.8
Bkg weight to get 2.0 Hz in pop PT5B = inf
Bkg weight to get 2.0 Hz in pop CT5B = 4.2
Bkg weight to get 2.0 Hz in pop IT6 = 10.2
Bkg weight to get 2.0 Hz in pop CT6 = 4.2
Bkg weight to get 2.0 Hz in pop TC = 0.4
Bkg weight to get 2.0 Hz in pop HTC = 0.5
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2
** v22_batch7 - fI curves for all cell types
** v22_batch8 - fI for new ITP4, IT5A
** v22_batch9 - fI with celsius=36
** v22_batch10 - fI with celsius=34
** v22_batch11 - fI for all cells with temp=36
** v22_batch12 - fI new cells with 37C tuned
** v22_batch13-17 - weightNorm all cells (Except 2) after retuning
*** notes
13 - ITs
16 - VIP
** v22_batch14 (overwrote) - fI for all cells
** v22_batch18-19 - weightNorm for TC and HTC and TI
** v22_batch20 - weightNorm for ITS4 (overwritten accidentally)
** v22_batch21 - bkg weights for all pops (E 20hz apicdend, I 40 Hz perisom) - bug, missing weightNorms
Bkg weight to get 2.0 Hz in pop IT2 = 22.0
Bkg weight to get 4.0 Hz in pop PV2 = 44.3
Bkg weight to get 4.0 Hz in pop SOM2 = 7.8
Bkg weight to get 4.0 Hz in pop VIP2 = 14.8
Bkg weight to get 4.0 Hz in pop NGF2 = 101.0
Bkg weight to get 2.0 Hz in pop IT3 = 11.6
Bkg weight to get 2.0 Hz in pop ITP4 = 5.0
Bkg weight to get 2.0 Hz in pop ITS4 = 1.5
Bkg weight to get 2.0 Hz in pop IT5A = 2.0
Bkg weight to get 2.0 Hz in pop CT5A = 9.0
Bkg weight to get 2.0 Hz in pop IT5B = 1.3
/usr/local/lib/python3.7/site-packages/scipy/interpolate/interpolate.py:610: RuntimeWarning: divide by zero encountered in true_divide
  slope = (y_hi - y_lo) / (x_hi - x_lo)[:, None]
Bkg weight to get 2.0 Hz in pop PT5B = inf
Bkg weight to get 2.0 Hz in pop CT5B = 9.0
Bkg weight to get 2.0 Hz in pop IT6 = 23.0
Bkg weight to get 2.0 Hz in pop CT6 = 9.0
Bkg weight to get 2.0 Hz in pop TC = 3.9
Bkg weight to get 2.0 Hz in pop HTC = 3.9
Bkg weight to get 4.0 Hz in pop IRE = 1.5
Bkg weight to get 4.0 Hz in pop TI = 5.3

** v22_batch22 - bkg weights for all pops (E 20hz soma, I 40 Hz soma) - bug, missing weightNorms

Bkg weight to get 2.0 Hz in pop IT2 = 22.0
Bkg weight to get 4.0 Hz in pop PV2 = 44.3
Bkg weight to get 4.0 Hz in pop SOM2 = 7.8
Bkg weight to get 4.0 Hz in pop VIP2 = 14.8
Bkg weight to get 4.0 Hz in pop NGF2 = 101.0
Bkg weight to get 2.0 Hz in pop IT3 = 21.2
Bkg weight to get 2.0 Hz in pop ITP4 = 2.8
Bkg weight to get 2.0 Hz in pop ITS4 = 1.5
Bkg weight to get 2.0 Hz in pop IT5A = 7.8
Bkg weight to get 2.0 Hz in pop CT5A = 6.2
Bkg weight to get 2.0 Hz in pop IT5B = 7.8
Bkg weight to get 2.0 Hz in pop PT5B = 20.7
Bkg weight to get 2.0 Hz in pop CT5B = 6.2
Bkg weight to get 2.0 Hz in pop IT6 = 9.7
Bkg weight to get 2.0 Hz in pop CT6 = 6.2
Bkg weight to get 2.0 Hz in pop TC = 3.9
Bkg weight to get 2.0 Hz in pop HTC = 3.9
Bkg weight to get 4.0 Hz in pop IRE = 1.5
Bkg weight to get 4.0 Hz in pop TI = 5.3

** v22_batch23 - missing weightNorms for CT5A and CT5B 
** v22_batch24 - bkg weights for all pops (E 40hz soma, I 40 Hz soma) - bug, missing NGF weightNorm!
Bkg weight to get 2.0 Hz in pop IT2 = 17.8
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = -106.7
Bkg weight to get 2.0 Hz in pop IT3 = 16.8
Bkg weight to get 2.0 Hz in pop ITP4 = 13.8
Bkg weight to get 2.0 Hz in pop ITS4 = 0.3
Bkg weight to get 2.0 Hz in pop IT5A = 24.4
Bkg weight to get 2.0 Hz in pop CT5A = 16.8
Bkg weight to get 2.0 Hz in pop IT5B = 23.0
Bkg weight to get 2.0 Hz in pop PT5B = 16.8
Bkg weight to get 2.0 Hz in pop CT5B = 16.8
Bkg weight to get 2.0 Hz in pop IT6 = 26.0
Bkg weight to get 2.0 Hz in pop CT6 = 16.8
Bkg weight to get 2.0 Hz in pop TC = 10.7
Bkg weight to get 2.0 Hz in pop HTC = 10.7
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

Note: but dynamic range looks better - can probably reduce to max weight 50 and have 0.5 intervals
** v22_batch25 - wnorm for missing NGF
** v22_batch26 - bkg weights for all pops (E 40hz soma, I 40 Hz soma); range 0,50,0.5

Bkg weight to get 2.0 Hz in pop IT2 = 17.8
Bkg weight to get 4.0 Hz in pop PV2 = 26.6
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.9
/usr/local/lib/python3.7/site-packages/scipy/interpolate/interpolate.py:610: RuntimeWarning: divide by zero encountered in true_divide
  slope = (y_hi - y_lo) / (x_hi - x_lo)[:, None]
Bkg weight to get 4.0 Hz in pop NGF2 = inf
Bkg weight to get 2.0 Hz in pop IT3 = 16.8
Bkg weight to get 2.0 Hz in pop ITP4 = 13.5
Bkg weight to get 2.0 Hz in pop ITS4 = 0.4
Bkg weight to get 2.0 Hz in pop IT5A = 28.2
Bkg weight to get 2.0 Hz in pop CT5A = 16.5
Bkg weight to get 2.0 Hz in pop IT5B = 23.0
Bkg weight to get 2.0 Hz in pop PT5B = 16.5
Bkg weight to get 2.0 Hz in pop CT5B = 16.5
Bkg weight to get 2.0 Hz in pop IT6 = 29.5
Bkg weight to get 2.0 Hz in pop CT6 = 16.5
Bkg weight to get 2.0 Hz in pop TC = 10.8
Bkg weight to get 2.0 Hz in pop HTC = 10.8
Bkg weight to get 4.0 Hz in pop IRE = 8.7
Bkg weight to get 4.0 Hz in pop TI = 48.2

range not enough to get spikes in NGF

** v22_batch27 - bkg weights for all pops (E 40hz soma, I 40 Hz soma); range 0,100
--> v22_sim1 (still depol block)
Bkg weight to get 2.0 Hz in pop IT2 = 17.8
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 2.0 Hz in pop IT3 = 16.8
Bkg weight to get 2.0 Hz in pop ITP4 = 13.8
Bkg weight to get 2.0 Hz in pop ITS4 = 0.3
Bkg weight to get 2.0 Hz in pop IT5A = 24.4
Bkg weight to get 2.0 Hz in pop CT5A = 16.8
Bkg weight to get 2.0 Hz in pop IT5B = 23.0
Bkg weight to get 2.0 Hz in pop PT5B = 16.8
Bkg weight to get 2.0 Hz in pop CT5B = 16.8
Bkg weight to get 2.0 Hz in pop IT6 = 26.0
Bkg weight to get 2.0 Hz in pop CT6 = 16.8
Bkg weight to get 2.0 Hz in pop TC = 10.7
Bkg weight to get 2.0 Hz in pop HTC = 10.7
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

  NGF1 : 5.331 Hz
   IT2 : 2.621 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 2.921 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 2.499 Hz
   ITS4 : 0.006 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 5.437 Hz
   CT5A : 2.535 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 2.335 Hz
   CT5B : 2.584 Hz
   PT5B : 2.575 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 1.679 Hz
   CT6 : 2.454 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 2.405 Hz
   TCM : 2.729 Hz
   HTC : 2.342 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz


Calculating bkg weights for each pop ...
Bkg weight to get 1.5 Hz in pop IT2 = 16.5
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 1.5 Hz in pop IT3 = 15.5
Bkg weight to get 1.5 Hz in pop ITP4 = 13.5
Bkg weight to get 1.5 Hz in pop ITS4 = 0.2
Bkg weight to get 1.5 Hz in pop IT5A = 18.0
Bkg weight to get 1.5 Hz in pop CT5A = 15.8
Bkg weight to get 1.5 Hz in pop IT5B = 13.0
Bkg weight to get 1.5 Hz in pop PT5B = 15.7
Bkg weight to get 1.5 Hz in pop CT5B = 15.8
Bkg weight to get 1.5 Hz in pop IT6 = 21.2
Bkg weight to get 1.5 Hz in pop CT6 = 15.8
Bkg weight to get 1.5 Hz in pop TC = 10.2
Bkg weight to get 1.5 Hz in pop HTC = 10.2
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

-- v22_sim4 (still depol block)
 NGF1 : 5.331 Hz
   IT2 : 1.763 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 1.972 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 2.152 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 9.359 Hz
   CT5A : 1.825 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 3.231 Hz
   CT5B : 1.932 Hz
   PT5B : 1.807 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 2.618 Hz
   CT6 : 1.796 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz


- adapted method to gradually increase num points used (avoids depol block)
Bkg weight to get 1.5 Hz in pop IT2 = 16.5
Bkg weight to get 4.0 Hz in pop PV2 = 32.3
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
/usr/local/lib/python3.7/site-packages/scipy/interpolate/interpolate.py:610: RuntimeWarning: divide by zero encountered in true_divide
  slope = (y_hi - y_lo) / (x_hi - x_lo)[:, None]
Bkg weight to get 4.0 Hz in pop NGF2 = 85.0
Bkg weight to get 1.5 Hz in pop IT3 = 15.5
Bkg weight to get 1.5 Hz in pop ITP4 = 13.5
Bkg weight to get 1.5 Hz in pop ITS4 = 0.2
Bkg weight to get 1.5 Hz in pop IT5A = 9.2
Bkg weight to get 1.5 Hz in pop CT5A = 15.8
Bkg weight to get 1.5 Hz in pop IT5B = 11.1
Bkg weight to get 1.5 Hz in pop PT5B = 15.7
Bkg weight to get 1.5 Hz in pop CT5B = 15.8
Bkg weight to get 1.5 Hz in pop IT6 = 19.6
Bkg weight to get 1.5 Hz in pop CT6 = 15.8
Bkg weight to get 1.5 Hz in pop TC = 10.2
Bkg weight to get 1.5 Hz in pop HTC = 10.2
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 2.6

-- v22_sim5
   NGF1 : 10.225 Hz
   IT2 : 1.763 Hz
   SOM2 : 4.800 Hz
   PV2 : 17.692 Hz
   VIP2 : 5.125 Hz
   NGF2 : 11.545 Hz
   IT3 : 1.972 Hz
   SOM3 : 4.400 Hz
   PV3 : 15.500 Hz
   VIP3 : 4.299 Hz
   NGF3 : 10.060 Hz
   ITP4 : 2.152 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 14.495 Hz
   VIP4 : 3.385 Hz
   NGF4 : 8.071 Hz
   IT5A : 1.830 Hz
   CT5A : 1.825 Hz
   SOM5A : 5.186 Hz
   PV5A : 15.356 Hz
   VIP5A : 3.400 Hz
   NGF5A : 9.875 Hz
   IT5B : 3.000 Hz
   CT5B : 1.932 Hz
   PT5B : 1.807 Hz
   SOM5B : 4.938 Hz
   PV5B : 14.478 Hz
   VIP5B : 5.353 Hz
   NGF5B : 9.875 Hz
   IT6 : 3.820 Hz
   CT6 : 1.796 Hz
   SOM6 : 5.095 Hz
   PV6 : 17.690 Hz
   VIP6 : 3.583 Hz
   NGF6 : 9.658 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 4.088 Hz

** v22_batch28 - bkg weights for all pops (E 40hz apic/adend1, I 40 Hz proximal)

*** E 2hz
Bkg weight to get 2.0 Hz in pop IT2 = 17.0
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 2.0 Hz in pop IT3 = 6.2
Bkg weight to get 2.0 Hz in pop ITP4 = 2.3
Bkg weight to get 2.0 Hz in pop ITS4 = 0.3
Bkg weight to get 2.0 Hz in pop IT5A = 24.1
Bkg weight to get 2.0 Hz in pop CT5A = 4.3
Bkg weight to get 2.0 Hz in pop IT5B = 31.8
/usr/local/lib/python3.7/site-packages/scipy/interpolate/interpolate.py:610: RuntimeWarning: divide by zero encountered in true_divide
  slope = (y_hi - y_lo) / (x_hi - x_lo)[:, None]
Bkg weight to get 2.0 Hz in pop PT5B = inf
Bkg weight to get 2.0 Hz in pop CT5B = 4.4
Bkg weight to get 2.0 Hz in pop IT6 = 10.0
Bkg weight to get 2.0 Hz in pop CT6 = 4.3
Bkg weight to get 2.0 Hz in pop TC = 10.7
Bkg weight to get 2.0 Hz in pop HTC = 10.7
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

*** if aim for E at 1 Hz then ok: --> v22_sim2
Bkg weight to get 1.0 Hz in pop IT2 = 14.7
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 1.0 Hz in pop IT3 = 6.0
Bkg weight to get 1.0 Hz in pop ITP4 = 2.2
Bkg weight to get 1.0 Hz in pop ITS4 = 0.1
Bkg weight to get 1.0 Hz in pop IT5A = 12.5
Bkg weight to get 1.0 Hz in pop CT5A = 4.2
Bkg weight to get 1.0 Hz in pop IT5B = 16.4
Bkg weight to get 1.0 Hz in pop PT5B = 23.0
Bkg weight to get 1.0 Hz in pop CT5B = 4.2
Bkg weight to get 1.0 Hz in pop IT6 = 9.0
Bkg weight to get 1.0 Hz in pop CT6 = 4.2
Bkg weight to get 1.0 Hz in pop TC = 9.7
Bkg weight to get 1.0 Hz in pop HTC = 9.7
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

  NGF1 : 5.331 Hz
   IT2 : 1.086 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 3.130 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 0.000 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 18.184 Hz
   CT5A : 1.978 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 13.231 Hz
   CT5B : 2.047 Hz
   PT5B : 0.692 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 20.595 Hz
   CT6 : 1.986 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.155 Hz
   TCM : 1.310 Hz
   HTC : 1.079 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz


*** if aim for E at 1.5 Hz then also ok: --> v22_sim3
Bkg weight to get 1.5 Hz in pop IT2 = 16.0
Bkg weight to get 4.0 Hz in pop PV2 = 26.5
Bkg weight to get 4.0 Hz in pop SOM2 = 4.4
Bkg weight to get 4.0 Hz in pop VIP2 = 7.8
Bkg weight to get 4.0 Hz in pop NGF2 = 75.5
Bkg weight to get 1.5 Hz in pop IT3 = 6.1
Bkg weight to get 1.5 Hz in pop ITP4 = 2.2
Bkg weight to get 1.5 Hz in pop ITS4 = 0.2
Bkg weight to get 1.5 Hz in pop IT5A = 18.3
Bkg weight to get 1.5 Hz in pop CT5A = 4.2
Bkg weight to get 1.5 Hz in pop IT5B = 24.1
Bkg weight to get 1.5 Hz in pop PT5B = 34.0
Bkg weight to get 1.5 Hz in pop CT5B = 4.3
Bkg weight to get 1.5 Hz in pop IT6 = 12.0
Bkg weight to get 1.5 Hz in pop CT6 = 4.2
Bkg weight to get 1.5 Hz in pop TC = 10.2
Bkg weight to get 1.5 Hz in pop HTC = 10.2
Bkg weight to get 4.0 Hz in pop IRE = 8.5
Bkg weight to get 4.0 Hz in pop TI = 48.2

   NGF1 : 5.331 Hz
   IT2 : 1.855 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 3.560 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 0.001 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 16.819 Hz
   CT5A : 2.409 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 11.616 Hz
   CT5B : 2.650 Hz
   PT5B : 1.376 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 5.206 Hz
   CT6 : 2.483 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz

*** v22_sim6 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling 10% IT6, IPT4,ITS4
  NGF1 : 5.331 Hz
   IT2 : 1.855 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 3.560 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 0.102 Hz
   ITS4 : 0.000 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 16.819 Hz
   CT5A : 2.409 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 11.616 Hz
   CT5B : 2.650 Hz
   PT5B : 1.376 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 8.822 Hz
   CT6 : 2.483 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz

   still depol block
*** v22_sim7 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling 25% IT6, IPT4,ITS4
   ITP4 : 0.626 Hz
   ITS4 : 0.000 Hz
   IT6 : 20.710 Hz
*** v22_sim8 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling 50% IT6, IPT4,ITS4
   ITP4 : 4.576 Hz
   ITS4 : 0.000 Hz
   IT6 : 35.489 Hz
*** v22_sim9 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4

   {'ITP4': 1.35, 'ITS4': 2.0, 'IT6': 0.25} 

      ITP4 : 1.730 Hz - ok
   ITS4 : 0.139 Hz - getting there, increase more
   IT6 : 0.126 Hz - too low now, increase

*** v22_sim10 (overwrote sim9) - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4

manualScaling = {'ITP4': 1.35, 'ITS4': 2.5, 'IT6': 0.3} 

   ITS4 : 0.980 Hz -- increase a but more: 3.0
   IT6 : 2.796 Hz -- decrease - 0.28

*** v22_sim11- bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4

manualScaling = {'ITP4': 1.35, 'ITS4': 3.0, 'IT6': 0.28} 
   ITS4 : 2.202 Hz
   IT6 : 1.150 Hz

*** v22_sim12 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4
   manualScaling = {'ITP4': 1.35, 'ITS4': 2.75, 'IT6': 0.27} 

      ITS4 : 1.558 Hz - ok
   IT6 : 0.708 Hz

*** v22_sim13 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); manualScaling custom IT6, IPT4,ITS4
   manualScaling = {'ITP4': 1.35, 'ITS4': 2.75, 'IT6': 0.29} 
   IT6 : 1.733 Hz

*** v22_sim14 - bkg weights for all pops (E 40hz apical, I 40 Hz proximal); after manual tuning IT6, IPT4,ITS4

  Cells: 12908
  Connections: 12908 (1.00 per cell)
  Synaptic contacts: 38724 (3.00 per cell)
  Spikes: 57788 (2.98 Hz)
   NGF1 : 5.331 Hz
   IT2 : 1.855 Hz
   SOM2 : 4.800 Hz
   PV2 : 5.231 Hz
   VIP2 : 5.125 Hz
   NGF2 : 6.273 Hz
   IT3 : 3.560 Hz
   SOM3 : 4.400 Hz
   PV3 : 5.330 Hz
   VIP3 : 4.299 Hz
   NGF3 : 5.313 Hz
   ITP4 : 1.767 Hz
   ITS4 : 1.578 Hz
   SOM4 : 5.083 Hz
   PV4 : 4.742 Hz
   VIP4 : 3.385 Hz
   NGF4 : 3.500 Hz
   IT5A : 16.819 Hz
   CT5A : 2.409 Hz
   SOM5A : 5.186 Hz
   PV5A : 5.055 Hz
   VIP5A : 3.400 Hz
   NGF5A : 5.250 Hz
   IT5B : 11.616 Hz
   CT5B : 2.650 Hz
   PT5B : 1.376 Hz
   SOM5B : 4.938 Hz
   PV5B : 4.828 Hz
   VIP5B : 5.353 Hz
   NGF5B : 5.500 Hz
   IT6 : 2.169 Hz
   CT6 : 2.483 Hz
   SOM6 : 5.095 Hz
   PV6 : 6.702 Hz
   VIP6 : 3.583 Hz
   NGF6 : 5.237 Hz
   TC : 1.767 Hz
   TCM : 1.968 Hz
   HTC : 1.632 Hz
   IRE : 4.258 Hz
   IREM : 4.077 Hz
   TI : 3.108 Hz
  Simulated time: 1.5 s; 4 workers
  Run time: 852.08 s

-- took quite a bit of manual tuning to fix those 3 cell types, but got nice results now… all spiking ~1-5 hz and no depol block
-- NOT TRUE!!! - IT5A, IT5B higher!


** v22_batch29 - Param sweep for conn
*** code
    params = specs.ODict()

    # conn gains
    params['EEGain'] = [0.5, 1.0, 1.5] #[0.5, 1.5] 
    params['EIGain'] = [0.5, 1.0, 1.5] 
    params['IEGain'] = [0.5, 1.0, 1.5] 
    params['IIGain'] = [0.5, 1.0, 1.5, 2.0]
    #params['thalamoCorticalGain'] = [0.5, 1.0, 1.5]  #2.5
    #params['intraThalamicGain'] = [0.5, 1.0, 1.5] #0.5
    #params['corticoThalamicGain'] = [0.5, 1.0, 1.5]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn '] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    return b
** v22_batch30 - explore NGF2+IT2 response to bkg inputs (4D params)
*** code

b = bkgWeights2D(pops = ['NGF2', 'IT2'], weights = list(np.arange(0,150,10)))

def bkgWeights2D(pops=[], weights=list(range(50))):

    params = specs.ODict()
    params['singlePop'] = pops
    params['weightBkgE'] = weights
    params['weightBkgI'] = weights
    params[('rateBkg', 'exc')] = [20, 40, 60, 80]
    params[('rateBkg', 'inh')] = [20, 40, 60, 80]

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 10.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg['singlePopForNetstim'] = True
    initCfg['removeWeightNorm'] = False
    initCfg[('analysis','plotTraces','include')] = [0]
    initCfg[('analysis','plotTraces','timeRange')] = [0, 3000]
    initCfg[('analysis', 'plotRaster')] = False

    initCfg[('rateBkg', 'exc')] = 40
    initCfg[('rateBkg', 'inh')] = 40

    ## turn off components not required
    initCfg['addBkgConn'] = True
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = False
    initCfg['addNetStim'] = False
** v22_batch31 - evol optim network (IE, II bug)
*** notes
bug in IE,II params
*** code
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.5, 1.5]
    params['EIGain'] = [0.5, 1.5]

    params[('IEweights', 0)] = [0.5, 1.5]
    params[('IEweights', 1)] = [0.5, 1.5]
    params[('IEweights', 2)] = [0.5, 1.5]

    params[('IIweights', 0)] = [0.5, 1.5]
    params[('IIweights', 1)] = [0.5, 1.5]
    params[('IIweights', 2)] = [0.5, 1.5]
*** results
gen_0_cand9: 
- cell 151 (IT2), 489 (SOM2), 494 (PV2), 507 (VIP2) - depol
- cell 6439 (ITS4) - high rate 
** v22_batch32 - explore ITS4 response to bkg inputs (4D params)
*** code
b = bkgWeights2D(pops = ['ITS4'], weights = list(np.arange(0,150,10)))

def bkgWeights2D(pops=[], weights=list(range(50))):

    params = specs.ODict()
    params['singlePop'] = pops
    params['weightBkgE'] = weights
    params['weightBkgI'] = weights
    params[('rateBkg', 'exc')] = [20, 40, 60, 80]
    params[('rateBkg', 'inh')] = [20, 40, 60, 80]

    # set initial config
    initCfg = {}
    # sim and recoring params
    initCfg['duration'] = 10.0 * 1e3
    initCfg['singleCellPops'] = True
    initCfg['singlePopForNetstim'] = True
    initCfg['removeWeightNorm'] = False
    initCfg[('analysis','plotTraces','include')] = [0]
    initCfg[('analysis','plotTraces','timeRange')] = [0, 3000]
    initCfg[('analysis', 'plotRaster')] = False

    initCfg[('rateBkg', 'exc')] = 40
    initCfg[('rateBkg', 'inh')] = 40

    ## turn off components not required
    initCfg['addBkgConn'] = True
    initCfg['addConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addIntraThalamicConn'] = False
    initCfg['addCorticoThalamicConn'] = False
    initCfg['addCoreThalamoCorticalConn'] = False
    initCfg['addMatrixThalamoCorticalConn'] = False
    initCfg['stimSubConn'] = False
    initCfg['addIClamp'] = False
    initCfg['addNetStim'] = False
** v23_batch1 - evol optim network 
*** note 
- running with scale density 50% 
-- small toy nets have all cells spiking
-- maybe issue is network scale -- cecilia's paper modifies weights by squared of scaling factor

- saving screen output to sim folder: https://stackoverflow.com/questions/54369613/cant-start-linux-screen-with-logging-to-specific-output-file
*** code

  # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.5, 1.5]
    params['EIGain'] = [0.5, 1.5]

    params[('IELayerGain', '1-3')] = [0.5, 1.5]
    params[('IELayerGain', '4')] = [0.5, 1.5]
    params[('IELayerGain', '5')] = [0.5, 1.5]
    params[('IELayerGain', '6')] = [0.5, 1.5]

    params[('IILayerGain', '1-3')] = [0.5, 1.5]
    params[('IILayerGain', '4')] = [0.5, 1.5]
    params[('IILayerGain', '5')] = [0.5, 1.5]
    params[('IILayerGain', '6')] = [0.5, 1.5]
    
    params['thalamoCorticalGain'] = [0.5, 1.5]  
    params['intraThalamicGain'] = [0.5, 1.5] 
    params['corticoThalamicGain'] = [0.5, 1.5]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        popFitness = [min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
                if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.items()]
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f'%(p, simData['popRates'][p], popFitness[i]) for i,p in enumerate(pops)])
        print('  '+popInfo)
        return fitness
    
    #from IPython import embed; embed()

    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    # Set evol alg configuration
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 100,
        'num_elites': 2,
        'mutation_rate': 0.5,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 200,
        'time_sleep': 300, # 5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 9, # (45) max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000, # set fitness value in case simulation time is over
        'scancelUser': 'ext_salvadordura_gmail_com'
    }

    return b

** v23_batch2 - evol optim network - density 50%
*** note 
- running with scale density 50% 
-- small toy nets have all cells spiking
-- maybe issue is network scale -- cecilia's paper modifies weights by squared of scaling factor

- saving screen output to sim folder: https://stackoverflow.com/questions/54369613/cant-start-linux-screen-with-logging-to-specific-output-file
*** code


** v23_batch3 - evol optim network - lower EE (0.1-0.5); longer evol timeout
*** note 
noticed mostly spiking too high or depol blocks; reduce overall excitation
*** code

** v23_batch4 - evol optim network - lower EE+EI (0.1-0.5); longer evol timeout
*** note
- noticed mostly spiking too high or depol blocks; reduce overall excitation to inh cells too
- fitness 237
- error when running 2 evol at same time - jobs of longer duration one get cancelled when jobs submitted


** v23_batch5- evol optim network - density 50%; lower EE+EI (0.1-0.5); wider range for IE+II (0.25-2.0)
*** note
make more flexible the IE II
** v23_batch6 - empty
** v23_batch7 - best soln from v23_batch5; explored thal conn
*** code
    params['EEGain'] = [0.10928952347451457, 0.05]
    params['EIGain'] = [0.13089042807412776, 0.05]
    params['thalamoCorticalGain'] = [1.964478741362849, 1.0, 3.0]
    params[('ICThalInput', 'probE')] = [0.12, 0.25, 0.5]
    params[('ICThalInput', 'probI')] = [0.12, 0.25, 0.5]
    

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 3000
    initCfg['printPopAvgRates'] = [250, 3000] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain']=0.10928952347451457
    initCfg['EIGain']=0.13089042807412776
    initCfg[('IELayerGain', '1-3')]=1.9475510641094371
    initCfg[('IELayerGain', '4')]=1.961577378323746
    initCfg[('IELayerGain', '5')]=0.73154575340036
    initCfg[('IELayerGain', '6')]=1.5743753119276733
    initCfg[('IILayerGain', '1-3')]=1.2715789518318394
    initCfg[('IILayerGain', '4')]=0.5633033925996949
    initCfg[('IILayerGain', '5')]=1.674448267759582
    initCfg[('IILayerGain', '6')]=0.8550747910383769
    initCfg['thalamoCorticalGain']=1.964478741362849
    initCfg['intraThalamicGain']=0.35778625557189936
    initCfg['corticoThalamicGain'] = 1.4715575641214615
** v23_batch8 - best soln from v23_batch5; explored thal conn (shorter sim)
*** code
    params['EEGain'] = [0.10928952347451457, 0.05]
    params['EIGain'] = [0.13089042807412776, 0.05]
    params['thalamoCorticalGain'] = [1.964478741362849, 1.0, 3.0]
    params[('ICThalInput', 'probE')] = [0.12, 0.25, 0.5]
    params[('ICThalInput', 'probI')] = [0.12, 0.25, 0.5]
    

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1750
    initCfg['printPopAvgRates'] = [250, 1750] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain']=0.10928952347451457
    initCfg['EIGain']=0.13089042807412776
    initCfg[('IELayerGain', '1-3')]=1.9475510641094371
    initCfg[('IELayerGain', '4')]=1.961577378323746
    initCfg[('IELayerGain', '5')]=0.73154575340036
    initCfg[('IELayerGain', '6')]=1.5743753119276733
    initCfg[('IILayerGain', '1-3')]=1.2715789518318394
    initCfg[('IILayerGain', '4')]=0.5633033925996949
    initCfg[('IILayerGain', '5')]=1.674448267759582
    initCfg[('IILayerGain', '6')]=0.8550747910383769
    initCfg['thalamoCorticalGain']=1.964478741362849
    initCfg['intraThalamicGain']=0.35778625557189936
    initCfg['corticoThalamicGain'] = 1.4715575641214615
** v23_batch9 - evol optim
*** code
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.1, 1.0]
    params['EIGain'] = [0.1, 1.0]

    params[('IELayerGain', '1-3')] = [0.25, 2.0]
    params[('IELayerGain', '4')] = [0.25, 2.0]
    params[('IELayerGain', '5')] = [0.25, 2.0]
    params[('IELayerGain', '6')] = [0.25, 2.0]

    params[('IILayerGain', '1-3')] = [0.25, 2.0]
    params[('IILayerGain', '4')] = [0.25, 2.0]
    params[('IILayerGain', '5')] = [0.25, 2.0]
    params[('IILayerGain', '6')] = [0.25, 2.0]
    
    params['thalamoCorticalGain'] = [0.25, 2.0]  
    params['intraThalamicGain'] = [0.25, 2.0] 
    params['corticoThalamicGain'] = [0.25, 2.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
*** results
best fitness so far
of course as mentioned fitness only looks at avg rate across 1 sec so not always best measure
but interesting because starting to show some osc
if look at this fig it’s clear that best soln’s are for the lowr EE gains — in this case range was 0.1 - 1.0
since still want to reduce excitability more potentially could reduce range of EEgain explore more (eg. [0.05, 0.25]) … however to avoid scaling down EE so much from orig values, was thinking of also trying to increase the range of IE more — currently [0.5, 2.0] so maybe allowing up to 4.0 or 5.0 … which I think should have similar effect to lowering EE
** v23_batch10 - evol optim net - density 100%; EE (0.05-0.5); EI (0.5-5.0)
*** notes
best fitness so far
of course as mentioned fitness only looks at avg rate across 1 sec so not always best measure
but interesting because starting to show some osc
if look at this fig it’s clear that best soln’s are for the lowr EE gains — in this case range was 0.1 - 1.0
since still want to reduce excitability more potentially could reduce range of EEgain explore more (eg. [0.05, 0.25]) … however to avoid scaling down EE so much from orig values, was thinking of also trying to increase the range of IE more — currently [0.5, 2.0] so maybe allowing up to 4.0 or 5.0 … which I think should have similar effect to lowering EE
*** code
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.05, 0.5]
    params['EIGain'] = [0.1, 1.0]

    params[('IELayerGain', '1-3')] = [0.25, 5.0]
    params[('IELayerGain', '4')] = [0.25, 5.0]
    params[('IELayerGain', '5')] = [0.25, 5.0]
    params[('IELayerGain', '6')] = [0.25, 5.0]

    params[('IILayerGain', '1-3')] = [0.25, 2.0]
    params[('IILayerGain', '4')] = [0.25, 2.0]
    params[('IILayerGain', '5')] = [0.25, 2.0]
    params[('IILayerGain', '6')] = [0.25, 2.0]
    
    params['thalamoCorticalGain'] = [0.25, 2.0]  
    params['intraThalamicGain'] = [0.25, 2.0] 
    params['corticoThalamicGain'] = [0.25, 2.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


** v23_batch11 - evol optim test new fitness func
*** code
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.05, 0.5]
    params['EIGain'] = [0.1, 2.0]

    params[('IELayerGain', '1-3')] = [0.25, 5.0]
    params[('IELayerGain', '4')] = [0.25, 5.0]
    params[('IELayerGain', '5')] = [0.25, 5.0]
    params[('IELayerGain', '6')] = [0.25, 5.0]

    params[('IILayerGain', '1-3')] = [0.25, 2.0]
    params[('IILayerGain', '4')] = [0.25, 2.0]
    params[('IILayerGain', '5')] = [0.25, 2.0]
    params[('IILayerGain', '6')] = [0.25, 2.0]
    
    params['thalamoCorticalGain'] = [0.25, 2.0]  
    params['intraThalamicGain'] = [0.25, 2.0] 
    params['corticoThalamicGain'] = [0.25, 2.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k][(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k][(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness

    
    #from IPython import embed; embed()

    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    # Set evol alg configuration
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 10,
        'num_elites': 2,
        'mutation_rate': 0.5,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 200,
        'time_sleep': 300, # 5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 9, # max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000, # set fitness value in case simulation time is over
        'scancelUser': 'ext_salvadordura_gmail_com'
    }

    return b

** v23_batch12 - evol optim, new fitness func, 50% density; increased ranges
*** notes
- can increase weight ranges because not taking into account num syns / conn
- total weight = syn weight * num syns * electrotonic -- many unknown variables == allowed variability 
*** code
    params = specs.ODict()

    # bkg inputs
    params['EEGain'] = [0.05, 0.5]
    params['EIGain'] = [0.1, 2.0]

    params[('IELayerGain', '1-3')] = [0.1, 10.0]
    params[('IELayerGain', '4')] = [0.1, 10.0]
    params[('IELayerGain', '5')] = [0.1, 10.0]
    params[('IELayerGain', '6')] = [0.1, 10.0]

    params[('IILayerGain', '1-3')] = [0.1, 10.0]
    params[('IILayerGain', '4')] = [0.1, 10.0]
    params[('IILayerGain', '5')] = [0.1, 10.0]
    params[('IILayerGain', '6')] = [0.1, 10.0]
    
    params['thalamoCorticalGain'] = [0.25, 2.0]  
    params['intraThalamicGain'] = [0.25, 2.0] 
    params['corticoThalamicGain'] = [0.25, 2.0]
*** results
gen_63_cand_19 - fitness 148.92

 EE 0.3303517319869238	
 EI 0.100023011	
 IE13 9.186950686 (1.0)
 IE4 6.160878748 (1.0)	
 IE5 1.729074111 (1.0)
 IE6 8.10671124 
 II1-3 8.454681919 (1.0)
 II4 9.44874377 (1.0)
 II5 2.310556658 (1.0)
 II6 1.578557048 
 TC 1.99495686	
 IT 0.521592918	 
 CT 1.6131164721326399]

 
** v24_batch1 - evol optim after fixing IE, II
*** note
only IE and II in L6 were working 
*** code
    # bkg inputs
    params['EEGain'] = [0.1, 1.0]
    params['EIGain'] = [0.2, 5.0]

    params[('IELayerGain', '1-3')] = [0.2, 5.0]
    params[('IELayerGain', '4')] = [0.2, 5.0]
    params[('IELayerGain', '5')] = [0.2, 5.0]
    params[('IELayerGain', '6')] = [0.2, 5.0]

    params[('IILayerGain', '1-3')] = [0.2, 5.0]
    params[('IILayerGain', '4')] = [0.2, 5.0]
    params[('IILayerGain', '5')] = [0.2, 5.0]
    params[('IILayerGain', '6')] = [0.2, 5.0]
    
    params['thalamoCorticalGain'] = [0.2, 5.0]  
    params['intraThalamicGain'] = [0.2, 5.0] 
    params['corticoThalamicGain'] = [0.2, 5.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
*** results
gen 38 cand 28 - fitness = 275.8

 EE 0.824146321526465	
 EI 0.200942767	
 IE13 3.751053243	
 IE4 4.780020172	
 IE5 0.200490707	
 IE6 4.742310303	
 II13 0.201356072	
 II4 1.846409498	
 II5 4.904555212	
 II6 2.374453718	
 TC 1.820561507	
 IT 0.852553584	 
 CT 3.077182476923463
** v24_batch2 -  evol optim with narrower range of params
*** code
    params['EEGain'] = [0.5, 2.0]
    params['EIGain'] = [0.5, 2.0]

    params[('IELayerGain', '1-3')] = [0.5, 2.0]
    params[('IELayerGain', '4')] = [0.5, 2.0]
    params[('IELayerGain', '5')] = [0.5, 2.0]
    params[('IELayerGain', '6')] = [0.5, 2.0]

    params[('IILayerGain', '1-3')] = [0.5, 2.0]
    params[('IILayerGain', '4')] = [0.5, 2.0]
    params[('IILayerGain', '5')] = [0.5, 2.0]
    params[('IILayerGain', '6')] = [0.5, 2.0]
    
    params['thalamoCorticalGain'] = [0.5, 2.0]  
    params['intraThalamicGain'] = [0.5, 2.0] 
    params['corticoThalamicGain'] = [0.5, 2.0]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]

    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False
*** results
gen 66 cand 8 - fitness = 311
 EE 1.7930365644528616	
 EI 1.301292631	
 IE 13, 4, 5, 6 
    1.9609935	
    1.973369532	
    0.547478256	
    0.817050621	
 II 13, 4, 5, 6
    0.575910457	
    0.506134474	
    1.140789303	
    1.999973065	
TC 1.434715802	
IT  1.987386358	 
CT 1.354024353042513


** v24_batch3 - param sweep starting from a good solution (run on my)
*** note
ran manually on my
modified param set 2, to be -0.3 instead of -0.2
*** code 
    # conn gains
    params[('IELayerGain', '1-3')] = [1.9609935, 1.9609935 - 0.1, 1.9609935 - 0.3] 
    params[('IELayerGain', '4')] = [1.973369532, 1.973369532 - 0.1, 1.973369532 - 0.3]
    params[('IELayerGain', '5')] = [0.547478256, 0.547478256 - 0.1, 0.547478256 - 0.3]	
    params[('IELayerGain', '6')] = [0.817050621, 0.817050621 - 0.1, 0.817050621 - 0.3]
    
    #params['thalamoCorticalGain'] = [1.964478741362849, 1.0, 3.0]
    #params[('ICThalInput', 'probE')] = [0.12, 0.25, 0.5]
    #params[('ICThalInput', 'probI')] = [0.12, 0.25, 0.5]
    
    groupedParams = [('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    #initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain'] = 1.7930365644528616
    initCfg['EIGain'] = 1.301292631	
    
    initCfg[('IELayerGain', '1-3')] = 1.9609935	
    initCfg[('IELayerGain', '4')] = 1.973369532	
    initCfg[('IELayerGain', '5')] = 0.547478256	
    initCfg[('IELayerGain', '6')] = 0.817050621	

    initCfg[('IILayerGain', '1-3')] = 0.575910457
    initCfg[('IILayerGain', '4')] = 0.506134474	
    initCfg[('IILayerGain', '5')] = 1.140789303	
    initCfg[('IILayerGain', '6')] = 1.999973065	

    initCfg['thalamoCorticalGain'] = 1.434715802
    initCfg['intraThalamicGain'] = 1.987386358	
    initCfg['corticoThalamicGain'] = 1.354024353042513

*** results
**** 0 (IE orig)
  Cells: 6442
  Connections: 0 (0.00 per cell)
  Spikes: 28832 (2.98 Hz)
   NGF1 : 0.027 Hz
   IT2 : 0.000 Hz
   SOM2 : 26.000 Hz
   PV2 : 2.000 Hz
   VIP2 : 41.000 Hz
   NGF2 : 2.000 Hz
   IT3 : 0.016 Hz
   SOM3 : 23.714 Hz
   PV3 : 3.602 Hz
   VIP3 : 42.210 Hz
   NGF3 : 0.080 Hz
   ITP4 : 0.002 Hz
   ITS4 : 0.079 Hz
   SOM4 : 9.833 Hz
   PV4 : 2.326 Hz
   VIP4 : 72.667 Hz
   NGF4 : 0.857 Hz
   IT5A : 1.564 Hz
   CT5A : 10.894 Hz
   SOM5A : 35.286 Hz
   PV5A : 1.306 Hz
   VIP5A : 2.400 Hz
   NGF5A : 0.500 Hz
   IT5B : 1.260 Hz
   CT5B : 9.723 Hz
   PT5B : 0.072 Hz
   SOM5B : 35.714 Hz
   PV5B : 0.851 Hz
   VIP5B : 2.250 Hz
   NGF5B : 0.583 Hz
   IT6 : 4.020 Hz
   CT6 : 13.966 Hz
   SOM6 : 81.387 Hz
   PV6 : 0.548 Hz
   VIP6 : 11.833 Hz
   NGF6 : 63.737 Hz
   TC : 5.431 Hz
   TCM : 0.442 Hz
   HTC : 6.105 Hz
   IRE : 7.273 Hz
   IREM : 0.545 Hz
   TI : 2.647 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 1269.69 s
Saving output as data/v24_batch3/v24_batch3_0_0_0_0.json  ... 
**** 1 (IE -0.1)
  Cells: 6442
  Connections: 0 (0.00 per cell)
  Spikes: 31700 (3.28 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   SOM2 : 38.500 Hz
   PV2 : 3.667 Hz
   VIP2 : 33.000 Hz
   NGF2 : 1.200 Hz
   IT3 : 0.065 Hz
   SOM3 : 37.714 Hz
   PV3 : 5.489 Hz
   VIP3 : 34.181 Hz
   NGF3 : 0.067 Hz
   ITP4 : 0.002 Hz
   ITS4 : 0.100 Hz
   SOM4 : 14.250 Hz
   PV4 : 4.239 Hz
   VIP4 : 85.000 Hz
   NGF4 : 1.286 Hz
   IT5A : 1.564 Hz
   CT5A : 12.486 Hz
   SOM5A : 41.857 Hz
   PV5A : 1.417 Hz
   VIP5A : 2.000 Hz
   NGF5A : 0.500 Hz
   IT5B : 1.230 Hz
   CT5B : 12.460 Hz
   PT5B : 0.123 Hz
   SOM5B : 44.482 Hz
   PV5B : 0.955 Hz
   VIP5B : 2.250 Hz
   NGF5B : 0.500 Hz
   IT6 : 3.988 Hz
   CT6 : 15.157 Hz
   SOM6 : 85.161 Hz
   PV6 : 0.524 Hz
   VIP6 : 11.667 Hz
   NGF6 : 71.263 Hz
   TC : 7.517 Hz
   TCM : 0.442 Hz
   HTC : 8.105 Hz
   IRE : 8.091 Hz
   IREM : 0.870 Hz
   TI : 2.863 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 1320.76 s
Saving output as data/v24_batch3/v24_batch3_1_1_1_1.json  ... 
Finished saving!
  Done; saving time = 2.22 s.
Plotting raster...
Plotting recorded cell traces ... trace
  Done; plotting time = 101.98 s

Total time = 3079.45 s
**** 2 (IE -0.3)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   SOM2 : 68.500 Hz
   PV2 : 0.333 Hz
   VIP2 : 8.250 Hz
   NGF2 : 0.400 Hz
   IT3 : 0.000 Hz
   SOM3 : 61.943 Hz
   PV3 : 0.864 Hz
   VIP3 : 12.143 Hz
   NGF3 : 0.013 Hz
   ITP4 : 0.000 Hz
   ITS4 : 0.000 Hz
   SOM4 : 19.000 Hz
   PV4 : 5.413 Hz
   VIP4 : 87.333 Hz
   NGF4 : 4.286 Hz
   IT5A : 1.380 Hz
   CT5A : 17.514 Hz
   SOM5A : 54.857 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   NGF5A : 0.000 Hz
   IT5B : 1.064 Hz
   CT5B : 18.817 Hz
   PT5B : 0.000 Hz
   SOM5B : 62.964 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 15.942 Hz
   SOM6 : 91.226 Hz
   PV6 : 0.000 Hz
   VIP6 : 5.167 Hz
   NGF6 : 84.789 Hz
   TC : 8.345 Hz
   TCM : 0.000 Hz
   HTC : 11.842 Hz
   IRE : 8.156 Hz
   IREM : 0.844 Hz
   TI : 3.392 Hz
  Simulated time: 1.5 s; 96 workers
  Run time: 1261.80 s

** v24_batch4 - v24_batch3 with IC inputs; running 'manually' on NSG
*** code
**** v24_batch4_0
"""
cfg.py 

Simulation configuration for A1 model (using NetPyNE)
This file has sim configs as well as specification for parameterized values in netParams.py 

Contributors: ericaygriffith@gmail.com, salvadordura@gmail.com
"""


from netpyne import specs
import pickle

cfg = specs.SimConfig()

#------------------------------------------------------------------------------
#
# SIMULATION CONFIGURATION
#
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Run parameters
#------------------------------------------------------------------------------
cfg.duration = 1.5*1e3			## Duration of the sim, in ms -- value from M1 cfg.py 
cfg.dt = 0.05                   ## Internal Integration Time Step -- value from M1 cfg.py 
cfg.verbose = 0         	## Show detailed messages
cfg.hParams['celsius'] = 37
cfg.createNEURONObj = 1
cfg.createPyStruct = 1
cfg.printRunTime = 0.1

cfg.connRandomSecFromList = False  # set to false for reproducibility 
cfg.cvode_active = False
cfg.cvode_atol = 1e-6
cfg.cache_efficient = True
cfg.printRunTime = 0.1
cfg.oneSynPerNetcon = False
cfg.includeParamsLabel = False
cfg.printPopAvgRates = [500, cfg.duration]

#------------------------------------------------------------------------------
# Recording 
#------------------------------------------------------------------------------
cfg.allpops = ['NGF1', 'IT2', 'PV2', 'SOM2', 'VIP2', 'NGF2', 'IT3', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'ITP4', 'ITS4', 'PV4', 'SOM4', 'VIP4', 'NGF4', 'IT5A', 'CT5A', 'PV5A', 'SOM5A', 'VIP5A', 'NGF5A', 'IT5B', 'PT5B', 'CT5B', 'PV5B', 'SOM5B', 'VIP5B', 'NGF5B', 'IT6', 'CT6', 'PV6', 'SOM6', 'VIP6', 'NGF6', 'TC', 'TCM', 'HTC', 'IRE', 'IREM', 'TI', 'IC']

alltypes = ['NGF1', 'IT2', 'PV2', 'SOM2', 'VIP2', 'ITS4', 'PT5B', 'TC', 'HTC', 'IRE', 'TI']

cfg.recordTraces = {'V_soma': {'sec':'soma', 'loc':0.5, 'var':'v'}}  ## Dict with traces to record -- taken from M1 cfg.py 
cfg.recordStim = False			## Seen in M1 cfg.py
cfg.recordTime = False  		## SEen in M1 cfg.py 
cfg.recordStep = 0.1            ## Step size (in ms) to save data -- value from M1 cfg.py 

#cfg.recordLFP = [[100, y, 100] for y in range(0, 2000, 400)]+[[100, 2500, 200], [100,2700,200]]

#------------------------------------------------------------------------------
# Saving
#------------------------------------------------------------------------------

cfg.simLabel = 'v24_batch3_0' 
cfg.saveFolder = '.'                	## Set file output name
cfg.savePickle = False         	## Save pkl file
cfg.saveJson = True           	## Save json file
cfg.saveDataInclude = ['simData', 'simConfig', 'netParams'] 
cfg.backupCfgFile = None 		
cfg.gatherOnlySimData = False	 
cfg.saveCellSecs = False		 
cfg.saveCellConns = False		 

#------------------------------------------------------------------------------
# Analysis and plotting 
#----------------------------------------------------------------------------- 

# cellGids = {'NGF1': 0, 'IT2': 45, 'SOM2': 146, 'PV2': 147, 'VIP2': 151, 'NGF2': 155, 'IT3': 158, 'SOM3': 1496, 'PV3': 1517, 'VIP3': 1569, 'NGF3': 1632, 'ITP4': 1677, 'ITS4': 1928, 'SOM4': 2179, 'PV4': 2186, 'VIP4': 2214, 'NGF4': 2218, 'IT5A': 2222, 'SOM5A': 2437, 'PV5A': 2450, 'VIP5A': 2472, 'NGF5A': 2475, 'IT5B': 2477, 'PT5B': 2689, 'SOM5B': 2901, 'PV5B': 2934, 'VIP5B': 2974, 'NGF5B': 2979, 'IT6': 2986, 'CT6': 3288, 'SOM6': 3590, 'PV6': 3609, 'VIP6': 3634, 'NGF6': 3637, 'TC': 3648, 'TCM': 3683, 'HTC': 3729, 'IRE': 3740, 'IREM': 3786}


# popGidRecord = [list(cellGids.values())[i] for i in [6,7,8,9,10,11,12,-1,-2,-3,-4,-5]]

cfg.analysis['plotTraces'] = {'include': [(pop, 0) for pop in alltypes], 'oneFigPer': 'trace', 'overlay': True, 'saveFig': True, 'showFig': False, 'figSize':(12,8)} #[(pop,0) for pop in alltypes]		## Seen in M1 cfg.py (line 68) 
cfg.analysis['plotRaster'] = {'include': cfg.allpops, 'saveFig': True, 'showFig': False, 'popRates': True, 'orderInverse': True, 'timeRange': [0,cfg.duration], 'figSize': (14,12), 'lw': 0.3, 'markerSize': 3, 'marker': '.', 'dpi': 300}      	## Plot a raster
#cfg.analysis['plotLFP'] = {'plots': ['timeSeries', 'PSD', 'spectrogram'], 'saveData': False, 'saveFig': True}
#cfg.analysis['plot2Dnet'] = True      	## Plot 2D visualization of cell positions & connections 


#------------------------------------------------------------------------------
# Cells
#------------------------------------------------------------------------------
cfg.weightNormThreshold = 5.0  # maximum weight normalization factor with respect to the soma

#------------------------------------------------------------------------------
# Synapses
#------------------------------------------------------------------------------
cfg.AMPATau2Factor = 1.0
cfg.synWeightFractionEE = [0.5, 0.5] # E->E AMPA to NMDA ratio
cfg.synWeightFractionEI = [0.5, 0.5] # E->I AMPA to NMDA ratio
cfg.synWeightFractionSOME = [0.9, 0.1] # SOM -> E GABAASlow to GABAB ratio
cfg.synWeightFractionNGF = [0.5, 0.5] # NGF GABAA to GABAB ratio


#------------------------------------------------------------------------------
# Network 
#------------------------------------------------------------------------------
## These values taken from M1 cfg.py (https://github.com/Neurosim-lab/netpyne/blob/development/examples/M1detailed/cfg.py)
cfg.singleCellPops = False
cfg.singlePop = ''
cfg.removeWeightNorm = False
cfg.scale = 1.0     # Is this what should be used? 
cfg.sizeY = 2000.0 #1350.0 in M1_detailed # should this be set to 2000 since that is the full height of the column? 
cfg.sizeX = 200.0 # 400 - This may change depending on electrode radius 
cfg.sizeZ = 200.0
cfg.scaleDensity = 0.5 #0.075 # Should be 1.0 unless need lower cell density for test simulation or visualization


#------------------------------------------------------------------------------
# Connectivity
#------------------------------------------------------------------------------
cfg.synWeightFractionEE = [0.5, 0.5] # E->E AMPA to NMDA ratio
cfg.synWeightFractionEI = [0.5, 0.5] # E->I AMPA to NMDA ratio
cfg.synWeightFractionIE = [0.9, 0.1]  # SOM -> E GABAASlow to GABAB ratio (update this)
cfg.synWeightFractionII = [0.9, 0.1]  # SOM -> E GABAASlow to GABAB ratio (update this)

# Cortical
cfg.addConn = 1

cfg.EEGain = 1.7930365644528616 
cfg.EIGain = 1.301292631	
cfg.IEGain = 1.0 #0.75
cfg.IIGain = 1.0 #0.5

## I->E/I layer weights (L1-3, L4, L5, L6)
cfg.IELayerGain = {'1-3': 1.9609935, '4': 1.973369532, '5': 0.547478256, '6': 0.817050621}
cfg.IILayerGain = {'1-3': 0.575910457, '4': 0.506134474, '5': 1.140789303, '6': 1.999973065}

# Thalamic
cfg.addIntraThalamicConn = 1.0
cfg.addIntraThalamicConn = 1.0
cfg.addCorticoThalamicConn = 1.0
cfg.addThalamoCorticalConn = 1.0

cfg.thalamoCorticalGain = 1.434715802
cfg.intraThalamicGain = 1.987386358	
cfg.corticoThalamicGain = 1.354024353042513

cfg.addSubConn = 1


#------------------------------------------------------------------------------
# Background inputs
#------------------------------------------------------------------------------
cfg.addBkgConn = 1
cfg.noiseBkg = 1.0  # firing rate random noise
cfg.delayBkg = 5.0  # (ms)
cfg.startBkg = 0  # start at 0 ms

# cfg.weightBkg = {'IT': 12.0, 'ITS4': 0.7, 'PT': 15.0, 'CT': 14.0,
#                 'PV': 28.0, 'SOM': 5.0, 'NGF': 80.0, 'VIP': 9.0,
#                 'TC': 1.8, 'HTC': 1.55, 'RE': 9.0, 'TI': 3.6}
cfg.rateBkg = {'exc': 40, 'inh': 40}

## options to provide external sensory input
cfg.randomThalInput = True  # provide random bkg inputs spikes (NetStim) to thalamic populations 

cfg.cochlearThalInput = False #{'numCells': 200, 'freqRange': [9*1e3, 11*1e3], 'toneFreq': 10*1e3, 'loudnessDBs': 50}  # parameters to generate realistic  auditory thalamic inputs using Brian Hears 

cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 'startTime': 500, 'weightE': 0.5, 'weightI': 0.5, 'probE': 0.12, 'probI': 0.26}  # parameters to generate realistic cochlear + IC input ; weight =unitary connection somatic EPSP (mV)


#------------------------------------------------------------------------------
# Current inputs 
#------------------------------------------------------------------------------
cfg.addIClamp = 0

#------------------------------------------------------------------------------
# NetStim inputs 
#------------------------------------------------------------------------------

cfg.addNetStim = 0

## LAYER 1
cfg.NetStim1 = {'pop': 'NGF1', 'ynorm': [0,2.0], 'sec': 'soma', 'loc': 0.5, 'synMech': ['AMPA'], 'synMechWeightFactor': [1.0], 'start': 0, 'interval': 1000.0/60.0, 'noise': 0.0, 'number': 0.0, 'weight': 10.0, 'delay': 0}

# ## LAYER 2
# cfg.NetStim2 = {'pop': 'IT2',  'ynorm': [0,1], 'sec': 'soma', 'loc': 0.5, 'synMech': ['AMPA'], 'synMechWeightFactor': [1.0], 'start': 0, 'interval': 1000.0/60.0, 'noise': 0.0, 'number': 60.0, 	'weight': 10.0, 'delay': 0}






** v24_batch5 - result from v24_batch3 with IC inputs and LFP recording; manually on 'my'
*** code
params = specs.ODict()

    # conn gains
    # params[('IELayerGain', '1-3')] = [1.9609935, 1.9609935 - 0.1, 1.9609935 - 0.2] 
    # params[('IELayerGain', '4')] = [1.973369532, 1.973369532 - 0.1, 1.973369532 - 0.2]
    # params[('IELayerGain', '5')] = [0.547478256, 0.547478256 - 0.1, 0.547478256 - 0.2]	
    # params[('IELayerGain', '6')] = [0.817050621, 0.817050621 - 0.1, 0.817050621 - 0.2]
    
    params['thalamoCorticalGain'] = [1.434715802, 2.0]
    #params[('ICThalInput', 'probE')] = [0.12, 0.25]#, 0.5]
    #params[('ICThalInput', 'probI')] = [0.12, 0.25]#, 0.5]
    
    groupedParams = [('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain'] = 1.7930365644528616
    initCfg['EIGain'] = 1.301292631	
    
    initCfg[('IELayerGain', '1-3')] = 1.9609935 - 0.15
    initCfg[('IELayerGain', '4')] = 1.973369532	- 0.15
    initCfg[('IELayerGain', '5')] = 0.547478256	- 0.15
    initCfg[('IELayerGain', '6')] = 0.817050621	- 0.15

    initCfg[('IILayerGain', '1-3')] = 0.575910457
    initCfg[('IILayerGain', '4')] = 0.506134474	
    initCfg[('IILayerGain', '5')] = 1.140789303	
    initCfg[('IILayerGain', '6')] = 1.999973065	

    initCfg['thalamoCorticalGain'] = 1.434715802
    initCfg['intraThalamicGain'] = 1.987386358	
    initCfg['corticoThalamicGain'] = 1.354024353042513

    
** v24_batch6 - rerun v23_batch8 with fixed LFP
*** notes
1_1_1_1_0
1_1_1_1_1
1_1_1_1_2

had to go to prev commit cause bkg inputs had changed

*** params
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1750
    initCfg['printPopAvgRates'] = [250, 1750] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    initCfg['EEGain']=0.10928952347451457
    initCfg['EIGain']=0.13089042807412776
    initCfg[('IELayerGain', '1-3')]=1.9475510641094371 1.0
    initCfg[('IELayerGain', '4')]=1.961577378323746 1.0
    initCfg[('IELayerGain', '5')]=0.73154575340036 1.0
    initCfg[('IELayerGain', '6')]=1.5743753119276733
    initCfg[('IILayerGain', '1-3')]=1.2715789518318394 1.0
    initCfg[('IILayerGain', '4')]=0.5633033925996949 1.0 
    initCfg[('IILayerGain', '5')]=1.674448267759582 1.0
    initCfg[('IILayerGain', '6')]=0.8550747910383769
    initCfg['thalamoCorticalGain']=1.964478741362849
    initCfg['intraThalamicGain']=0.35778625557189936
    initCfg['corticoThalamicGain'] = 1.4715575641214615
*** code
    params = specs.ODict()

    # conn gains
    # params[('IELayerGain', '1-3')] = [1.9609935, 1.9609935 - 0.1, 1.9609935 - 0.2] 
    # params[('IELayerGain', '4')] = [1.973369532, 1.973369532 - 0.1, 1.973369532 - 0.2]
    # params[('IELayerGain', '5')] = [0.547478256, 0.547478256 - 0.1, 0.547478256 - 0.2]	
    # params[('IELayerGain', '6')] = [0.817050621, 0.817050621 - 0.1, 0.817050621 - 0.2]
    
    #params['thalamoCorticalGain'] = [1.434715802, 2.0]
    #params[('ICThalInput', 'probE')] = [0.12, 0.25]#, 0.5]
    params[('ICThalInput', 'probI')] = [0.12, 0.25, 0.5]
    
    groupedParams = [] #('IELayerGain', '1-3'), ('IELayerGain', '4'), ('IELayerGain', '5'), ('IELayerGain', '6')]

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1750
    initCfg['printPopAvgRates'] = [250, 1750] 
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotLFP', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['addConn'] = True # test only bkg inputs

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    ''' from v23_batch8'''
    initCfg['EEGain']=0.10928952347451457
    initCfg['EIGain']=0.13089042807412776
    initCfg[('IELayerGain', '1-3')]= 1.0
    initCfg[('IELayerGain', '4')]=1.0
    initCfg[('IELayerGain', '5')]=1.0
    initCfg[('IELayerGain', '6')]=1.5743753119276733
    initCfg[('IILayerGain', '1-3')]=1.0
    initCfg[('IILayerGain', '4')]=1.0 
    initCfg[('IILayerGain', '5')]=1.0
    initCfg[('IILayerGain', '6')]=0.8550747910383769
    initCfg['thalamoCorticalGain']=1.964478741362849
    initCfg['intraThalamicGain']=0.35778625557189936
    initCfg['corticoThalamicGain'] = 1.4715575641214615
    
** v24_batch7 - fI for ITS4 and VIP to check diam change didn't affect
*** results
OK, same fI, didn't affect.

** v24_batch8 - fI for ITS4 with old diam (3um)
*** results
pretty similar to new diam (25um); but steeper curve so keeping 25um

** v24_batch9 - asd optim on 'zn' 96 cores (6 gens) (bug: IC input)
*** notes
test with toy model first
*** code
def asdRates():

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs

    params['EEGain'] = [0.5, 2.0, 1.7930365644528616]
    params['EIGain'] = [0.5, 2.0, 1.301292631]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, 1.9609935]
    params[('IELayerGain', '4')] = [0.5, 2.0, 1.973369532]
    params[('IELayerGain', '5')] = [0.5, 2.0, 0.547478256]
    params[('IELayerGain', '6')] = [0.5, 2.0, 0.817050621]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, 0.575910457]
    params[('IILayerGain', '4')] = [0.5, 2.0, 0.506134474]
    params[('IILayerGain', '5')] = [0.5, 2.0, 1.140789303]
    params[('IILayerGain', '6')] = [0.5, 2.0, 1.999973065]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, 1.434715802]  
    params['intraThalamicGain'] = [0.5, 2.0, 1.987386358] 
    params['corticoThalamicGain'] = [0.5, 2.0, 1.354024353042513]

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'asd'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'stepsize':     0.1,     #   Initial step size as a fraction of each parameter
        'sinc':         1.5,       #   Step size learning rate (increase)
        'sdec':         1.5,       #   Step size learning rate (decrease)
        'pinc':         2,       #   Parameter selection learning rate (increase)
        'pdec':         2,       #   Parameter selection learning rate (decrease)
        #'pinitial':     None,    #    Set initial parameter selection probabilities
        #'sinitial':     None,    #    Set initial step sizes; if empty, calculated from stepsize instead
        'maxiters':     200,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      360000,    #    Maximum time allowed, in seconds
        'abstol':       1e-6,    #    Minimum absolute change in objective function
        'reltol':       1e-3,    #    Minimum relative change in objective function
        #'stalliters':   10*len(params)*len(params),  #    Number of iterations over which to calculate TolFun (n = number of parameters)
        #'stoppingfunc': None,    #    External method that can be used to stop the calculation from the outside.
        #'randseed':     None,    #    The random seed to use
        'verbose':      2,       #    How much information to print during the run
        #'label':        None    #    A label to use to annotate the output
        'time_sleep': 60, # 2.5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 30, # max number of times to check if sim is completed (for each generation)
    }
*** results
stopped after 6 gens  -- not sure why

    "fvals": [
        323.4898722376168,
        323.4898722376168,
        293.7585341348848,
        293.7585341348848,
        293.7585341348848,
        293.7585341348848,
        0.0,
        0.0,
 "x": [
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.575910457,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.575910457,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.5183194113,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.5183194113,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.5183194113,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            1.7930365644528616,
            1.301292631,
            1.9609935,
            1.973369532,
            0.547478256,
            0.817050621,
            0.5183194113,
            0.506134474,
            1.140789303,
            1.999973065,
            1.434715802,
            1.987386358,
            1.354024353042513
        ],
        [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ],
        [


set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=2.0
set ('IELayerGain', '5')=0.547478256
set ('IELayerGain', '6')=0.817050621
set ('IILayerGain', '1-3')=0.5183194113
set ('IILayerGain', '4')=0.506134474
set ('IILayerGain', '5')=1.140789303
set ('IILayerGain', '6')=1.999973065
set thalamoCorticalGain=1.434715802
set intraThalamicGain=1.987386358
set corticoThalamicGain=1.354024353042513


** v24_batch10 - asd optim on 'zn' 96 cores; continue from v24_batch9 (bug)
** v24_batch11 - asd optim on 'zn' 96 cores; continue from v24_batch9 (bug: IC input) 
*** notes
not reproducible cause was using IC input (should only be bkg), and turns out IC input is random every time

set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=2.0
set ('IELayerGain', '5')=0.547478256
set ('IELayerGain', '6')=0.817050621
set ('IILayerGain', '1-3')=0.5183194113
set ('IILayerGain', '4')=0.506134474
set ('IILayerGain', '5')=1.140789303
set ('IILayerGain', '6')=1.999973065
set thalamoCorticalGain=1.434715802
set intraThalamicGain=1.987386358
set corticoThalamicGain=1.354024353042513

using asd parallel implementation with single starting point
using psutil to cancel jobs

crashed because no try excpet around psutil (tried to stop nrniv from other user I guess)
*** code

ef asdRates():

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs

    params['EEGain'] = [0.5, 2.0, 1.7930365644528616]
    params['EIGain'] = [0.5, 2.0, 1.301292631]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, 1.9609935]
    params[('IELayerGain', '4')] = [0.5, 2.0, 2.0]
    params[('IELayerGain', '5')] = [0.5, 2.0, 0.547478256]
    params[('IELayerGain', '6')] = [0.5, 2.0, 0.817050621]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, 0.5183194113]
    params[('IILayerGain', '4')] = [0.5, 2.0, 0.506134474]
    params[('IILayerGain', '5')] = [0.5, 2.0, 1.140789303]
    params[('IILayerGain', '6')] = [0.5, 2.0, 1.999973065]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, 1.434715802]  
    params['intraThalamicGain'] = [0.5, 2.0, 1.987386358] 
    params['corticoThalamicGain'] = [0.5, 2.0, 1.354024353042513]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'asd'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'stepsize':     0.1,     #   Initial step size as a fraction of each parameter
        'sinc':         1.5,       #   Step size learning rate (increase)
        'sdec':         1.5,       #   Step size learning rate (decrease)
        'pinc':         2,       #   Parameter selection learning rate (increase)
        'pdec':         2,       #   Parameter selection learning rate (decrease)
        #'pinitial':     None,    #    Set initial parameter selection probabilities
        #'sinitial':     None,    #    Set initial step sizes; if empty, calculated from stepsize instead
        'maxiters':     100,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      360000,    #    Maximum time allowed, in seconds
        'abstol':       1e-6,    #    Minimum absolute change in objective function
        'reltol':       1e-3,    #    Minimum relative change in objective function
        #'stalliters':   10*len(params)*len(params),  #    Number of iterations over which to calculate TolFun (n = number of parameters)
        #'stoppingfunc': None,    #    External method that can be used to stop the calculation from the outside.
        #'randseed':     None,    #    The random seed to use
        'verbose':      2,       #    How much information to print during the run
        #'label':        None    #    A label to use to annotate the output
        'time_sleep': 60, # 2.5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 30, # max number of times to check if sim is completed (for each generation)
    }
*** results
zn% head -n 100 $models/A1/data/v24_batch11/v24_batch11_output.json
{
    "fvals": [
        [
            299.70709812373457,
            299.70709812373457,
            293.76296218967843,
            293.76296218967843,
            293.76296218967843,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.8902649918624,
            287.84085789123134,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.8189938215254,
            287.7895153611463,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,
            281.8085323839038,


params for 1st 281.8085323839038:

                1.7930365644528616,
                1.301292631,
                1.9609935,
                1.8666666666666667,
                0.547478256,
                0.8715206624,
                0.57015135243,
                0.506134474,
                1.140789303,
                1.999973065,
                1.2912442218,
                1.7886477222,
                1.4894267883467642
** v24_batch12 - asd optim on 'zn' 96 cores; continue from v24_batch11 (bug: IC input)
*** notes
not reproducible cause was using IC input, and turns out IC input is random every time


fixed parallel asd by adding try excpet around psutil
continue from v24_batch11:
                1.7930365644528616,
                1.301292631,
                1.9609935,
                1.8666666666666667,
                0.547478256,
                0.8715206624,
                0.57015135243,
                0.506134474,
                1.140789303,
                1.999973065,
                1.2912442218,
                1.7886477222,
                1.4894267883467642
*** code

    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # bkg inputs

    params['EEGain'] = [0.5, 2.0, [1.7930365644528616]]
    params['EIGain'] = [0.5, 2.0, [1.301292631]]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, [1.9609935]]
    params[('IELayerGain', '4')] = [0.5, 2.0, [1.8666666666666667]]
    params[('IELayerGain', '5')] = [0.5, 2.0, [0.547478256]]
    params[('IELayerGain', '6')] = [0.5, 2.0, [0.8715206624]]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, [0.57015135243]]
    params[('IILayerGain', '4')] = [0.5, 2.0, [0.506134474]]
    params[('IILayerGain', '5')] = [0.5, 2.0, [1.140789303]]
    params[('IILayerGain', '6')] = [0.5, 2.0, [1.999973065]]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, [1.2912442218]]  
    params['intraThalamicGain'] = [0.5, 2.0, [1.7886477222]]
    params['corticoThalamicGain'] = [0.5, 2.0, [1.4894267883467642]]


    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [[500, 750], [750, 1000], [1000, 1250], [1250, 1500]]
    initCfg['dt'] = 0.05

    initCfg['scaleDensity'] = 0.5

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'timeRange')] = [500,1500]
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'
    initCfg['recordLFP'] = None
    initCfg[('analysis', 'plotLFP')] = False

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT3', 'ITP4', 'ITS4', 'IT5A', 'CT5A', 'IT5B', 'PT5B', 'CT5B', 'IT6', 'CT6', 'TC', 'TCM', 'HTC']  # all layers + thal + IC

    Etune = {'target': 5, 'width': 20, 'min': 0.05}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1',                            # L1
            'PV2', 'SOM2', 'VIP2', 'NGF2',      # L2
            'PV3', 'SOM3', 'VIP3', 'NGF3',      # L3
            'PV4', 'SOM4', 'VIP4', 'NGF4',      # L4
            'PV5A', 'SOM5A', 'VIP5A', 'NGF5A',  # L5A  
            'PV5B', 'SOM5B', 'VIP5B', 'NGF5B',  # L5B
            'PV6', 'SOM6', 'VIP6', 'NGF6',       # L6
            'IRE', 'IREM', 'TI']  # Thal 

    Itune = {'target': 10, 'width': 30, 'min': 0.05}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000
    fitnessFuncArgs['tranges'] = initCfg['printPopAvgRates']


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        tranges = kwargs['tranges']

        popFitnessAll = []

        for trange in tranges:
            popFitnessAll.append([min(np.exp(abs(v['target'] - simData['popRates'][k]['%d_%d'%(trange[0], trange[1])])/v['width']), maxFitness) 
                if simData['popRates'][k]['%d_%d'%(trange[0], trange[1])] > v['min'] else maxFitness for k, v in pops.items()])
        
        popFitness = np.mean(np.array(popFitnessAll), axis=0)
        
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f' % (p, np.mean(list(simData['popRates'][p].values())), popFitness[i]) for i,p in enumerate(pops)])
        print('  ' + popInfo)

        return fitness
        
    # create Batch object with paramaters to modify, and specifying files to use
    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    b.method = 'asd'

    b.optimCfg = {
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'stepsize':     0.1,     #   Initial step size as a fraction of each parameter
        'sinc':         1.5,       #   Step size learning rate (increase)
        'sdec':         1.5,       #   Step size learning rate (decrease)
        'pinc':         2,       #   Parameter selection learning rate (increase)
        'pdec':         2,       #   Parameter selection learning rate (decrease)
        #'pinitial':     None,    #    Set initial parameter selection probabilities
        #'sinitial':     None,    #    Set initial step sizes; if empty, calculated from stepsize instead
        'maxiters':     100,    #    Maximum number of iterations (1 iteration = 1 function evaluation)
        'maxtime':      360000,    #    Maximum time allowed, in seconds
        'abstol':       1e-6,    #    Minimum absolute change in objective function
        'reltol':       1e-3,    #    Minimum relative change in objective function
        #'stalliters':   10*len(params)*len(params),  #    Number of iterations over which to calculate TolFun (n = number of parameters)
        #'stoppingfunc': None,    #    External method that can be used to stop the calculation from the outside.
        #'randseed':     None,    #    The random seed to use
        'verbose':      2,       #    How much information to print during the run
        #'label':        None    #    A label to use to annotate the output
        'time_sleep': 60, # 2.5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 30,  # max number of times to check if sim is completed (for each generation)
        'popsize': 1
    }
*** results
params for gen 37 (last improvement):
set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=1.8666666666666667
set ('IELayerGain', '5')=0.547478256
set ('IELayerGain', '6')=0.9586727286400001
set ('IILayerGain', '1-3')=0.57015135243
set ('IILayerGain', '4')=0.5567479214
set ('IILayerGain', '5')=1.140789303
set ('IILayerGain', '6')=1.9110853732222222
set thalamoCorticalGain=1.2912442218
set intraThalamicGain=1.7886477222
set corticoThalamicGain=1.4894267883467642


            293.74052987739645,
            293.74052987739645,
            293.74052987739645,
            293.74052987739645,
            293.70094352945284,
            293.70094352945284,
            293.70094352945284,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7770994875725,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            287.7703753723922,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            281.8273278878959,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786,
            269.8779437853786
** v24_batch13 - asd optim on 'zn' 96 cores; continue from v24_batch12 (bug: IC input)
not reproducible cause was using IC input (should only be bkg), and turns out IC input is random every time

set EEGain=1.7930365644528616
set EIGain=1.301292631
set ('IELayerGain', '1-3')=1.9609935
set ('IELayerGain', '4')=1.8666666666666667
set ('IELayerGain', '5')=0.547478256
set ('IELayerGain', '6')=0.9586727286400001
set ('IILayerGain', '1-3')=0.57015135243
set ('IILayerGain', '4')=0.5567479214
set ('IILayerGain', '5')=1.140789303
set ('IILayerGain', '6')=1.9110853732222222
set thalamoCorticalGain=1.2912442218
set intraThalamicGain=1.7886477222
set corticoThalamicGain=1.4894267883467642

** v24_batch14 - asd optimi on 'zn' 96 cores; from v24_batch2 (after removing IC)
*** notes
    params['EEGain'] = [0.5, 2.0, 1.7930365644528616]
    params['EIGain'] = [0.5, 2.0, 1.301292631]

    params[('IELayerGain', '1-3')] = [0.5, 2.0, 1.9609935]
    params[('IELayerGain', '4')] = [0.5, 2.0, 1.973369532]
    params[('IELayerGain', '5')] = [0.5, 2.0, 0.547478256]
    params[('IELayerGain', '6')] = [0.5, 2.0, 0.817050621]

    params[('IILayerGain', '1-3')] = [0.5, 2.0, 0.575910457]
    params[('IILayerGain', '4')] = [0.5, 2.0, 0.506134474]
    params[('IILayerGain', '5')] = [0.5, 2.0, 1.140789303]
    params[('IILayerGain', '6')] = [0.5, 2.0, 1.999973065]
    
    params['thalamoCorticalGain'] = [0.5, 2.0, 1.434715802]  
    params['intraThalamicGain'] = [0.5, 2.0, 1.987386358] 
    params['corticoThalamicGain'] = [0.5, 2.0, 1.354024353042513]
*** 

** new