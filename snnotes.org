
* 20mar5 - setting up
** cloned from https://github.com/NathanKlineInstitute/A1

then made a new branch samn off of salva branch
for now, will use samn for development ...

** wav files converted to mat to send to model

data is in data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat
so those are spikes from inferior colliculus

can take a look to see how it looks ...

** make sure using py3env

now setup laptop to use anaconda with neurosim dir structures
so, that py3env uses python 3.6 with anaconda ... 

** compile

nrnivmodl mod

** run

make a myrun script wrapper
that contains
mpiexec -n $1 nrniv -python -mpi init.py

init.py is entry point for network model

which param to scale down so can run on laptop?

sal mentioned:
cfg.scaleDensity — if you set to 0.025 it's ~400 cells, runs in 60 sec

try out a 2 s sim with scale of 0.025 ...

myrun 8

with scale of 1.0 there are 1607 cells on each node ... for 12856 cells total ... too much
for lowly laptop ...

with scale of 0.025, 8 cores, ~43-44 cells per node ...

  Done; run time = 28.73 s; real-time ratio: 0.07.

  Cells: 347
  Connections: 7412 (21.36 per cell)
  Synaptic contacts: 14473 (41.71 per cell)
  Spikes: 1830 (2.64 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.083 Hz
   IT3 : 0.204 Hz
   SOM3 : 50.000 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.167 Hz
   ITS4 : 9.633 Hz
   PV4 : 0.000 Hz
   IT5A : 3.417 Hz
   CT5A : 0.083 Hz
   SOM5A : 38.000 Hz
   PV5A : 0.000 Hz
   IT5B : 0.606 Hz
   CT5B : 0.000 Hz
   PT5B : 0.061 Hz
   SOM5B : 34.000 Hz
   PV5B : 0.000 Hz
   IT6 : 2.213 Hz
   CT6 : 0.133 Hz
   SOM6 : 39.333 Hz
   PV6 : 0.000 Hz
   TC : 0.000 Hz
   TCM : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   IC : 11.373 Hz
  Simulated time: 2.0 s; 8 workers
  Run time: 28.73 s
Saving output as data/v11_manualTune//v11_sim52.json  ...

most cells not firing ...

could run scale of 0.1 for ~1300 cells ...

myrun 8

getting lots of these errors: exp(inf) out of range, returning exp(700)

  Cells: 1313
  Connections: 130037 (99.04 per cell)
  Synaptic contacts: 253484 (193.06 per cell)
  Spikes: 4513 (1.72 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.049 Hz
   SOM3 : 56.381 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.056 Hz
   ITS4 : 3.398 Hz
   SOM4 : 62.667 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.248 Hz
   CT5A : 0.000 Hz
   SOM5A : 32.667 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.113 Hz
   CT5B : 0.000 Hz
   PT5B : 0.014 Hz
   SOM5B : 37.030 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.147 Hz
   CT6 : 0.100 Hz
   SOM6 : 34.444 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 0.000 Hz
   TCM : 0.000 Hz
   HTC : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   IC : 10.933 Hz
  Simulated time: 2.0 s; 8 workers
  Run time: 359.73 s
Saving output as data/v11_manualTune//v11_sim52.json  ... 
Finished saving!
Done; saving time = 1.06 s.

at this scale, have lots of populations not firing at all as well ...

are there exp(inf) warnings for scale of 1 too?

try 200 ms sim at that scale to see ... (the warnings started before sim reached 100 ms)

myrun 8

yeah, looks like get same errors at scale of 1
exp(inf) out of range, returning exp(700)

takes a while to get network wired, of course ... millions of synapses per node

then crashes eventually with out of memory problem ... when it gets to gather:

Gathering data...
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
[samndp7730:13791] *** Process received signal ***
[samndp7730:13791] Signal: Aborted (6)
[samndp7730:13791] Signal code:  (-6)

* 20mar6 - testing/tuning manually
** reading code/testing/tuning smaller version of model

in the 0.1 scaledensity simulation, the IC cells are firing ~8 Hz when providing
the auditory input signal ... but the TC cells are not firing at all

SOM cells fire too much, most other populations do not fire too much

myrun 12

  Cells: 1313
  Connections: 130037 (99.04 per cell)
  Synaptic contacts: 253484 (193.06 per cell)
  Spikes: 4526 (1.72 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.049 Hz
   SOM3 : 56.381 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.056 Hz
   ITS4 : 3.398 Hz
   SOM4 : 62.667 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.248 Hz
   CT5A : 0.000 Hz
   SOM5A : 32.667 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.113 Hz
   CT5B : 0.000 Hz
   PT5B : 0.014 Hz
   SOM5B : 37.030 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.147 Hz
   CT6 : 0.100 Hz
   SOM6 : 34.444 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 0.000 Hz
   TCM : 0.000 Hz
   HTC : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   IC : 11.107 Hz
  Simulated time: 2.0 s; 12 workers
  Run time: 327.72 s
  Saving output as data/20mar6//20mar6_A0.pkl ...

so, where is connection from IC -> THAL ?   

in cfg.py have this:
cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_9600_10400_wav_01_ba_peter.mat', 'startTime': 500}  # parameters to generate realistic cochlear + IC input

and in netParams.py have this:
if cfg.ICThalInput:
which loads spikes from file and then creates VecStims like this:
netParams.popParams['IC'] = {'cellModel': 'VecStim', 'numCells': numCells, 'ynormRange': layer['cochlear'],'spkTimes': spkTimes}
but, do not see the weight set ...aha, it's set below as
    # connect cochlear + IC thalamic inputs
    if cfg.ICThalInput:
        netParams.connParams['IC->ThalE'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.probInput['ThalE'],
            'weight': cfg.weightInput['ThalE'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalI'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['RE']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.probInput['ThalI'], 
            'weight': cfg.weightInput['ThalI'],
            'synMechWeightFactor': cfg.synWeightFractionEI,
            'delay': cfg.delayBkg}  

so, to increase weight of those IC inputs just increase cfg.weightInput['ThalE'] and/or cfg.weightInput['ThalI']

try that out . . .

even if that works should have some activity throughout the network in the absence of auditory inputs

hmm, still have 0 TC rates:
   TC : 0.000 Hz
   TCM : 0.000 Hz
   HTC : 0.000 Hz
   IRE : 0.000 Hz
   IREM : 0.000 Hz
   IC : 11.440 Hz

   did not seem to impact TC rates ... or activity

data/20mar6/20mar6_A0_traces_gid_1204.png   
data/20mar6/20mar6_A0_traces_gid_1215.png
data/20mar6/20mar6_A0_traces_gid_1230.png
data/20mar6/20mar6_A0_traces_gid_1233.png
data/20mar6/20mar6_A0_traces_gid_1248.png
data/20mar6/20mar6_A0_traces_gid_1263.png
raster: data/20mar6/20mar6_A0_raster.png

probably because no inputs at all ??
cfg.probInput = {'ThalE': 0.0, 'ThalI': 0.0} # {'ThalE': 0.25, 'ThalI': 0.25}  # probability of conn

so need to set that to a positive value ...

ok, put those weights back to 0.5 and put the probabilities at 0.25 ... see how it looks

myrun 12

ok, looks a lot different now, though still a lot of types not firing at all:

  Cells: 1313
  Connections: 130736 (99.57 per cell)
  Synaptic contacts: 254882 (194.12 per cell)
  Spikes: 5384 (2.05 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.000 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.054 Hz
   SOM3 : 57.429 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.056 Hz
   ITS4 : 3.655 Hz
   SOM4 : 64.000 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.248 Hz
   CT5A : 0.000 Hz
   SOM5A : 32.833 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.142 Hz
   CT5B : 0.000 Hz
   PT5B : 0.014 Hz
   SOM5B : 39.394 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.260 Hz
   CT6 : 0.113 Hz
   SOM6 : 34.556 Hz
   PV6 : 0.083 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 10.727 Hz
   TCM : 11.156 Hz
   HTC : 8.222 Hz
   IRE : 6.089 Hz
   IREM : 4.800 Hz
   IC : 11.573 Hz
  Simulated time: 2.0 s; 12 workers
  Run time: 353.24 s

data/20mar6/20mar6_A0_traces_gid_1204.png   
data/20mar6/20mar6_A0_traces_gid_1215.png
data/20mar6/20mar6_A0_traces_gid_1230.png
data/20mar6/20mar6_A0_traces_gid_1233.png
data/20mar6/20mar6_A0_traces_gid_1248.png
data/20mar6/20mar6_A0_traces_gid_1263.png
raster: data/20mar6/20mar6_A0_raster.png

seems like SOM cells overactive in every layer ... that's probably leading to suppression of everything else ...

try turning down I -> E gain ... and I -> I gain ... and EIGain (in cfg.py)

cfg.EEGain = 1.0 
cfg.EIGain = 0.75 # 1.0 #0.75
cfg.IEGain = 0.75 # 1.0 #0.75
cfg.IIGain = 0.75 # 1.0 #0.5

cfg.simLabel = '20mar6_A1'

myrun 12

data/20mar6/20mar6_A1_traces_gid_1204.png   
data/20mar6/20mar6_A1_traces_gid_1215.png
data/20mar6/20mar6_A1_traces_gid_1230.png
data/20mar6/20mar6_A1_traces_gid_1233.png
data/20mar6/20mar6_A1_traces_gid_1248.png
data/20mar6/20mar6_A1_traces_gid_1263.png
raster: data/20mar6/20mar6_A1_raster.png

did not make much difference...

SOM still dominating ...

  Cells: 1313
  Connections: 130736 (99.57 per cell)
  Synaptic contacts: 254882 (194.12 per cell)
  Spikes: 5849 (2.23 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.020 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.139 Hz
   SOM3 : 60.952 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.185 Hz
   ITS4 : 5.390 Hz
   SOM4 : 65.000 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.438 Hz
   CT5A : 0.000 Hz
   SOM5A : 34.667 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.113 Hz
   CT5B : 0.000 Hz
   PT5B : 0.014 Hz
   SOM5B : 41.455 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.073 Hz
   CT6 : 0.147 Hz
   SOM6 : 34.444 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 8.364 Hz
   TCM : 10.711 Hz
   HTC : 9.111 Hz
   IRE : 5.956 Hz
   IREM : 4.800 Hz
   IC : 11.160 Hz

test with IEGain of 0 to see if E cells activate without the inhib inputs ...

cfg.simLabel = '20mar6_A2'
cfg.IEGain = 0.0 # 0.75 # 1.0 #0.75

myrun 12

data/20mar6/20mar6_A2_traces_gid_1204.png   
data/20mar6/20mar6_A2_traces_gid_1215.png
data/20mar6/20mar6_A2_traces_gid_1230.png
data/20mar6/20mar6_A2_traces_gid_1233.png
data/20mar6/20mar6_A2_traces_gid_1248.png
data/20mar6/20mar6_A2_traces_gid_1263.png
raster: data/20mar6/20mar6_A2_raster.png

well, it has some impact but E populations are mostly silent ...

  Spikes: 14203 (5.41 Hz)
   NGF1 : 0.000 Hz
   IT2 : 10.222 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.555 Hz
   SOM3 : 105.333 Hz
   PV3 : 41.882 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.000 Hz
   ITS4 : 17.839 Hz
   SOM4 : 96.667 Hz
   PV4 : 19.704 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 0.000 Hz
   CT5A : 0.000 Hz
   SOM5A : 44.667 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.000 Hz
   CT5B : 0.000 Hz
   PT5B : 1.830 Hz
   SOM5B : 54.485 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 3.627 Hz
   CT6 : 0.280 Hz
   SOM6 : 36.333 Hz
   PV6 : 7.750 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 7.455 Hz
   TCM : 8.889 Hz
   HTC : 3.333 Hz
   IRE : 6.756 Hz
   IREM : 5.956 Hz
   IC : 10.640 Hz

and try another with cortical connectivity turned off ... (may need to adjust the noise inputs)
cfg.simLabel = '20mar6_A3'   
cfg.addConn = 0   

myrun 12

  Spikes: 6048 (2.30 Hz)
   NGF1 : 0.000 Hz
   IT2 : 0.020 Hz
   PV2 : 0.000 Hz
   VIP2 : 0.000 Hz
   NGF2 : 0.000 Hz
   IT3 : 0.081 Hz
   SOM3 : 38.190 Hz
   PV3 : 0.000 Hz
   VIP3 : 0.000 Hz
   NGF3 : 0.000 Hz
   ITP4 : 0.120 Hz
   ITS4 : 10.048 Hz
   SOM4 : 42.333 Hz
   PV4 : 0.000 Hz
   VIP4 : 0.000 Hz
   NGF4 : 0.000 Hz
   IT5A : 3.048 Hz
   CT5A : 0.133 Hz
   SOM5A : 35.833 Hz
   PV5A : 0.000 Hz
   VIP5A : 0.000 Hz
   IT5B : 0.922 Hz
   CT5B : 0.099 Hz
   PT5B : 0.071 Hz
   SOM5B : 41.030 Hz
   PV5B : 0.000 Hz
   VIP5B : 0.000 Hz
   NGF5B : 0.000 Hz
   IT6 : 2.733 Hz
   CT6 : 0.120 Hz
   SOM6 : 33.333 Hz
   PV6 : 0.000 Hz
   VIP6 : 0.000 Hz
   NGF6 : 0.000 Hz
   TC : 8.970 Hz
   TCM : 8.622 Hz
   HTC : 5.111 Hz
   IRE : 6.133 Hz
   IREM : 5.911 Hz
   IC : 10.853 Hz

data/20mar6/20mar6_A3_traces_gid_1204.png   
data/20mar6/20mar6_A3_traces_gid_1215.png
data/20mar6/20mar6_A3_traces_gid_1230.png
data/20mar6/20mar6_A3_traces_gid_1233.png
data/20mar6/20mar6_A3_traces_gid_1248.png
data/20mar6/20mar6_A3_traces_gid_1263.png
raster: data/20mar6/20mar6_A3_raster.png
   
ok, SOM still firing but not much from the other types ... can adjust noise inputs first;
to aim for ~1 Hz firing of all types ... ? or perhaps only E types ... 

* 20oct22 - back to model
** back to model -- git merge samn with salva so have latest

cloned onto cycle

git clone git@github.com:NathanKlineInstitute/A1.git
cd A1
git branch
git pull origin salva
git branch
git checkout samn
git merge origin/salva
Auto-merging netParams.py
CONFLICT (content): Merge conflict in netParams.py
Auto-merging cfg.py
CONFLICT (content): Merge conflict in cfg.py
Automatic merge failed; fix conflicts and then commit the result.
git add netParams.py cfg.py
git commit -m 'merge'
git push origin samn
git mv snnotes.dol snnotes.org
git commit -m 'to org'
git push origin samn

** homeostatic synapses to regulate/tune firing rates

can either do via hsyn.mod or in py with periodic callbacks - similar to smartagent weight normalizations

http://www.netpyne.org/reference.html?highlight=hsyn

** old NetPyNE slack discussion on using hsyn.mod in NetPyNE (from 5/4/20)

Haroon Anwar It appears that homeostatic synaptic plasticity is associated with the synaptic
mechanism (and therefore should be set/declared in netParams.synMechParams) instead of synaptic
connection (as in case of STDP rule). I see the following lines on NetPyNe website but it is not
clear to me how to use this option: selfNetCon (optional) - dictionary with the parameters of a
NetCon between the cell voltage and the synapse, required by some synaptic mechanisms such as the
homeostatic synapse (hsyn). e.g. 'selfNetCon': {'sec': 'soma' , 'threshold': -15, 'weight': -1,
'delay': 0}
salvadord think we had an example with homeostatic syns — did you find that? otherwise I’ll look for it after lunch
Haroon Anwar no i didn’t find. If you can look for it, would be great help.
salvadord not finding the example… what was the name of the mod file for homeostatic syns?
samn:speech_balloon: hsyn.mod
salvadord thx
salvadord haroon, found this in sam’s netpyne version of m1 model from ~2017 … maybe try
something similar and let me know if works: netParams.synMechParams['AMPA'] =
{'mod':'hsyn','tau1':0.05,'tau2':5.3,'e':0,'scaling':1,'targetrate':5,'scalefactor':1.0,'scaleratefctr':scaleratefctr,
'selfNetCon': {'threshold': -15, 'weight': -1, 'delay': 0}}
Haroon Anwar ok
let me try
Haroon Anwar salva, can you please send me the link to this m1 model?
salvadord this version is in /u/samn/m1np
Haroon Anwar thanks

** test net

using a scaled down version for testing
cfg.scaledensity=0.1

for plotting, do not call matplotlib.use('Agg') on cycle ... just on server (gcp)

./myrun 30

** replace AMPA with hsyn 

will need diff AMPA mech for E and I neurons ...

netParams.synMechParams['AMPA'] = {'mod':'hsyn','tau1':0.05,'tau2':5.3,'e':0,'scaling':1,'targetrate':5,'scalefactor':1.0,'scaleratefctr':scaleratefctr,
'selfNetCon': {'threshold': -15, 'weight': -1, 'delay': 0}}

ok, adjusting to have option whether to use the homeostatic scaling ... ideally would want to have param
for different target rates for each population ... will add that in if/when basic mechanism is working

* 23aug2
** sz modeling

EG had szdelta branch, pull from there and merge with samn

git pull origin szdelta

From github.com:NathanKlineInstitute/A1
 * branch            szdelta    -> FETCH_HEAD
Auto-merging netParams.py
CONFLICT (content): Merge conflict in netParams.py
Auto-merging init.py
CONFLICT (content): Merge conflict in init.py
Auto-merging cfg.py
CONFLICT (content): Merge conflict in cfg.py
Automatic merge failed; fix conflicts and then commit the result.

ok, fixed/updated those files and commited ... will stick with samn branch moving forward

* 23aug3
** test run

nrnivmodl mod

./myrun 30

  Cells: 1273
  Connections: 0 (0.00 per cell)
  Spikes: 112493 (8.84 Hz)
  Simulated time: 10.0 s; 30 workers
  Run time: 205.01 s
   NGF1 : 3.421 Hz
   IT2 : 4.434 Hz
   PV2 : 132.900 Hz
   VIP2 : 15.700 Hz
   NGF2 : 13.400 Hz
   IT3 : 3.694 Hz
   SOM3 : 22.914 Hz
   PV3 : 27.712 Hz
   VIP3 : 19.390 Hz
   NGF3 : 6.540 Hz
   ITP4 : 7.131 Hz
   ITS4 : 5.891 Hz
   SOM4 : 14.650 Hz
   PV4 : 21.100 Hz
   VIP4 : 29.400 Hz
   NGF4 : 7.700 Hz
   IT5A : 2.309 Hz
   CT5A : 1.300 Hz
   SOM5A : 22.200 Hz
   PV5A : 41.467 Hz
   VIP5A : 62.700 Hz
   IT5B : 6.496 Hz
   CT5B : 0.373 Hz
   PT5B : 0.615 Hz
   SOM5B : 48.440 Hz
   PV5B : 32.569 Hz
   VIP5B : 7.000 Hz
   NGF5B : 5.300 Hz
   IT6 : 15.431 Hz
   CT6 : 12.926 Hz
   SOM6 : 60.150 Hz
   PV6 : 37.138 Hz
   NGF6 : 94.100 Hz
   TC : 41.000 Hz
   TCM : 39.147 Hz
   HTC : 57.750 Hz
   IRE : 4.027 Hz
   IREM : 3.107 Hz
   TI : 18.380 Hz
   TIM : 18.300 Hz
Saving output as data/23aug3_A0/23aug3_A0_data.pkl ... 
Finished saving!
  Done; saving time = 2.56 s.

pretty fast runtime ... a little over 3 minutes for 10 s of simulation ...

but this was at 10% density:
cfg.scaleDensity # 0.1

ok, much slower with 100% density ... (on cycle with 30 cores)

  Cells: 12908
  Connections: 0 (0.00 per cell)
  Spikes: 273942 (2.12 Hz)
  Simulated time: 10.0 s; 30 workers
  Run time: 7604.76 s
   NGF1 : 1.752 Hz
   IT2 : 0.484 Hz
   SOM2 : 32.900 Hz
   PV2 : 12.138 Hz
   VIP2 : 24.233 Hz
   NGF2 : 10.791 Hz
   IT3 : 0.209 Hz
   SOM3 : 1.147 Hz
   PV3 : 9.172 Hz
   VIP3 : 20.003 Hz
   NGF3 : 5.747 Hz
   ITP4 : 0.495 Hz
   ITS4 : 0.475 Hz
   SOM4 : 1.639 Hz
   PV4 : 5.221 Hz
   VIP4 : 15.131 Hz
   NGF4 : 8.023 Hz
   IT5A : 2.140 Hz
   CT5A : 0.779 Hz
   SOM5A : 3.250 Hz
   PV5A : 4.764 Hz
   VIP5A : 18.070 Hz
   NGF5A : 14.550 Hz
   IT5B : 4.446 Hz
   CT5B : 0.242 Hz
   PT5B : 0.196 Hz
   SOM5B : 13.161 Hz
   PV5B : 2.560 Hz
   VIP5B : 13.600 Hz
   NGF5B : 15.643 Hz
   IT6 : 1.339 Hz
   CT6 : 0.892 Hz
   SOM6 : 47.630 Hz
   PV6 : 0.363 Hz
   VIP6 : 8.275 Hz
   NGF6 : 81.697 Hz
   TC : 4.940 Hz
   TCM : 5.097 Hz
   HTC : 4.384 Hz
   IRE : 2.783 Hz
   IREM : 3.198 Hz
   TI : 1.976 Hz
   TIM : 3.241 Hz

will setup simdat.py for easier load/analysis of sim data ... 

* 23aug5
** info from eg

Hi all, 

Hope you are doing well! I made a summary of those latest results as requested. 

Here is a google drive directory with data files, summary documents, and slides:  https://drive.google.com/drive/folders/16XWvAeeessXokFPRn3B7PBM7zKy-qdko?usp=sharing 

The Summary_BBN google slides doc shows the figures, and the notes section of each slide shows how to reproduce those figures. 

Data files and more detailed summaries are located in each of the two main subdirectories of that google drive folder (they are called model_vs_NHP and NMDA). Each of those subdirs has a summary document that details the steps I took. 

Let me know if there are any permissions issues or any issues reproducing the figs.

* 23aug7
** continue
* 23aug10
** continue test on edge

with 30 cores: 
  Done; run time = 4884.62 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 50.09 s.

Analyzing...
  Cells: 12908
  Connections: 0 (0.00 per cell)
  Spikes: 235909 (1.83 Hz)
  Simulated time: 10.0 s; 30 workers
  Run time: 4884.62 s
   NGF1 : 1.697 Hz
   IT2 : 0.261 Hz
   SOM2 : 16.040 Hz
   PV2 : 8.469 Hz
   VIP2 : 24.775 Hz
   NGF2 : 8.727 Hz
   IT3 : 0.156 Hz
   SOM3 : 0.843 Hz
   PV3 : 4.789 Hz
   VIP3 : 15.738 Hz
   NGF3 : 4.935 Hz
   ITP4 : 0.287 Hz
   ITS4 : 0.287 Hz
   SOM4 : 0.946 Hz
   PV4 : 2.958 Hz
   VIP4 : 12.131 Hz
   NGF4 : 6.050 Hz
   IT5A : 1.557 Hz
   CT5A : 0.464 Hz
   SOM5A : 2.291 Hz
   PV5A : 1.893 Hz
   VIP5A : 8.710 Hz
   NGF5A : 10.750 Hz
   IT5B : 3.406 Hz
   CT5B : 0.133 Hz
   PT5B : 0.130 Hz
   SOM5B : 11.856 Hz
   PV5B : 0.940 Hz
   VIP5B : 7.076 Hz
   NGF5B : 9.617 Hz
   IT6 : 0.678 Hz
   CT6 : 0.532 Hz
   SOM6 : 22.943 Hz
   PV6 : 44.274 Hz
   VIP6 : 52.917 Hz
   NGF6 : 45.032 Hz
   TC : 4.501 Hz
   TCM : 4.436 Hz
   HTC : 4.087 Hz
   IRE : 2.546 Hz
   IREM : 3.082 Hz
   TI : 1.800 Hz
   TIM : 3.067 Hz

hmm, number of spikes is much different compared to the run on cycle ... 
also does not finish saving data 

  Saving output as: 23aug3_B0_node_8.pkl ... 
  Done; saving time = 3.65 s.

Searching for .pkl node files in data/23aug3_B0/23aug3_B0_node_data ...

Gathering data from files for simulation: 23aug3_B0 ...
  Merging data file: 23aug3_B0_node_0.pkl
Traceback (most recent call last):
  File "init.py", line 48, in <module>
    sim.gatherDataFromFiles()
  File "/home/samn/netpyne/netpyne/sim/gather.py", line 426, in gatherDataFromFiles
    allCells.extend([cell.__getstate__() for cell in data['cells']])
  File "/home/samn/netpyne/netpyne/sim/gather.py", line 426, in <listcomp>
    allCells.extend([cell.__getstate__() for cell in data['cells']])
AttributeError: 'dict' object has no attribute '__getstate__'
bash: /opt/miniconda3/envs/py376/lib/libtinfo.so.6: no version information available (required by bash)

(py376) samn@edge:~/A1$ python
Python 3.7.6 (default, Jan  8 2020, 19:59:22) 
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import neuron
>>> neuron.__version__
'8.2.2'
>>> import netpyne
>>> netpyne.__version__
'1.0.4.2'
>>> 

and on cycle:
(base) samn@cycle:~/accumnavnet$ python
Python 3.7.6 (default, Jan  8 2020, 19:59:22) 
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import netpyne
>>> netpyne.__version__
'1.0.2.1'
>>> import neuron
>>> neuron.__version__
'8.0.2'
>>> 

so, older versions of both on cycle ... 

can also try on edge w/o the gatherdatafromfiles ... 

had an extra call to gatherdata ... will try again w/o it...

and try with 60 cores ... see if that speeds up (took ~180 minutes with 30 cores on edge)

./myrun 60

  Done; run time = 4239.55 s; real-time ratio: 0.00.

took ~70 minutes ...

Saving an output file for each node in: data/23aug10_A0/23aug10_A0_node_data
Searching for .pkl node files in data/23aug10_A0/23aug10_A0_node_data ...

Gathering data from files for simulation: 23aug10_A0 ...
  Merging data file: 23aug10_A0_node_0.pkl
Traceback (most recent call last):
  File "init.py", line 48, in <module>
    sim.gatherDataFromFiles()
  File "/home/samn/netpyne/netpyne/sim/gather.py", line 426, in gatherDataFromFiles
    allCells.extend([cell.__getstate__() for cell in data['cells']])
  File "/home/samn/netpyne/netpyne/sim/gather.py", line 426, in <listcomp>
    allCells.extend([cell.__getstate__() for cell in data['cells']])
AttributeError: 'dict' object has no attribute '__getstate__'

so, get the same error as before ...

will install versions used on cycle

pip uninstall neuron
pip uninstall netpyne

pip install neuron==8.0.2
pip install netpyne==1.0.2.1

ok, try that again ...

./myrun 48

  Cells: 12908
  Connections: 0 (0.00 per cell)
  Spikes: 205839 (1.59 Hz)
  Simulated time: 10.0 s; 48 workers
  Run time: 3904.57 s
   NGF1 : 1.673 Hz
   IT2 : 0.193 Hz
   SOM2 : 12.540 Hz
   PV2 : 4.015 Hz
   VIP2 : 23.019 Hz
   NGF2 : 7.960 Hz
   IT3 : 0.141 Hz
   SOM3 : 0.858 Hz
   PV3 : 2.888 Hz
   VIP3 : 11.005 Hz
   NGF3 : 4.669 Hz
   ITP4 : 0.189 Hz
   ITS4 : 0.204 Hz
   SOM4 : 0.804 Hz
   PV4 : 1.532 Hz
   VIP4 : 7.777 Hz
   NGF4 : 4.979 Hz
   IT5A : 1.247 Hz
   CT5A : 0.242 Hz
   SOM5A : 2.129 Hz
   PV5A : 0.571 Hz
   VIP5A : 3.378 Hz
   NGF5A : 6.300 Hz
   IT5B : 2.579 Hz
   CT5B : 0.063 Hz
   PT5B : 0.082 Hz
   SOM5B : 12.238 Hz
   PV5B : 0.248 Hz
   VIP5B : 1.731 Hz
   NGF5B : 5.279 Hz
   IT6 : 0.540 Hz
   CT6 : 0.340 Hz
   SOM6 : 12.087 Hz
   PV6 : 66.013 Hz
   VIP6 : 68.082 Hz
   NGF6 : 31.905 Hz
   TC : 4.322 Hz
   TCM : 4.186 Hz
   HTC : 4.057 Hz
   IRE : 2.533 Hz
   IREM : 2.982 Hz
   TI : 1.858 Hz
   TIM : 3.162 Hz
Saving output as data/23aug10_A0/23aug10_A0_data.pkl ... 
Finished saving!
  Done; saving time = 30.59 s.

ok, ran to completion ... and took ~65 minutes with 48 cores

** neuron/netpyne version used in A1 paper: neuron==7.8.2 and netpyne==1.0.2.1
* 23aug14
** check output from 23aug10_A0_

python -i simdat.py

loading data from 23aug10_A0
Traceback (most recent call last):
  File "simdat.py", line 132, in <module>
    simConfig, dstartidx, dendidx, dnumc, dspkID, dspkT = loadsimdat(name,lpop=[])
  File "simdat.py", line 28, in loadsimdat
    if simConfig['net']['pops'][p]['tags']['numCells'] > 0:
KeyError: 'tags'

no 'tags' used here

name = '23aug10_A0'
simConfig = pickle.load(open('data/'+name+'/'+name+'_data.pkl','rb'))
simConfig['net']['pops'].keys()
odict_keys(['NGF1', 'IT2', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'IT3', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'ITP4', 'ITS4', 'SOM4', 'PV4', 'VIP4', 'NGF4', 'IT5A', 'CT5A', 'SOM5A', 'PV5A', 'VIP5A', 'NGF5A', 'IT5B', 'CT5B', 'PT5B', 'SOM5B', 'PV5B', 'VIP5B', 'NGF5B', 'IT6', 'CT6', 'SOM6', 'PV6', 'VIP6', 'NGF6', 'TC', 'TCM', 'HTC', 'IRE', 'IREM', 'TI', 'TIM'])
simConfig['net']['pops']['NGF1'].keys() # odict_keys(['cellType', 'cellModel', 'ynormRange', 'density', 'pop', 'numCells', 'cellGids'])
simConfig['net']['pops']['NGF1']['numCells'] # 151

python -i simdat.py

** updated code from repro branch

this was the branch eg used for BBN, ERP, NMDA adjustment figures

most of the changes were in analysis subfolder

** next runs -- BBN
* 23aug15
** check LFP presence

python -i simdat.py

savefig('gif/23aug15_rast_a0.png') # [[./gif/23aug15_rast_a0.png]]

xlim((9e3,10e3))

savefig('gif/23aug15_rast_a0b.png') # [[./gif/23aug15_rast_a0b.png]]

some rhythmicity there in thalamic populations, have to check if providing auditory stim

len(simConfig['simData']['LFP']) # 100000

clf()

plot(simConfig['simData']['t'],simConfig['simData']['LFP'])

savefig('gif/23aug15_LFP_a1.png') # [[./gif/23aug15_LFP_a1.png]]

strange transition at the end

xlim((2e3,3e3)); ylim((-1.1,.65))

savefig('gif/23aug15_LFP_a2.png') # [[./gif/23aug15_LFP_a2.png]]

some useful plotting routines already in analysis subfolder (some of it is from OEvent code)

from analysis.simDataAnalysis import *

** setting up rhythmic BBN input
* 23aug23
** how to run BBN

check here
https://github.com/NathanKlineInstitute/A1/commit/c4011870a4c1617ca8b4d056dbed494e3e18f706

uses batch.py in repro branch, and there's a custom_BBN function there
that runs with and without the BBN stimulus ... 

* 23aug24
** testing BBN batch

http://www.netpyne.org/tutorial.html#tutorial-8-running-batch-simulations

mpiexec -np 48 nrniv -python -mpi batch.py

hmm, getting issues running using mpiexec ... creates configs but does not actually run them

** info from SD

sd: for BBN here’s the data: https://drive.google.com/drive/folders/1FYnlTBrS2WVvHAa6LWNoeq03v-O9496P?usp=drive_link
and this some summary erica sent: https://docs.google.com/document/d/1E0EHdja1HpzQKHa0q5WqGRP386xjEYs_wHDLz2xanLI/edit
sn: thanks...will try run it...for BBN using the ICThalInput
sd:  this also best ERP matches from erica: https://docs.google.com/document/d/1eY1Vfk0wmd62bgWuM-FA1WA2Ma2RDSHecWJ6oDKTMTY/edit?usp=sharing
and best BBN CSD matches: https://docs.google.com/document/d/1Lnt68zwRfQ8hzUx_B0DguUBNeyEr05m0abCs1JMn5IE/edit?usp=sharing
the ERP fig I shared above is for SOA850
sn: if i was going to optimize model to match ERPs to experiment ... could focus on dipoles, CSD, or LFP ... and adjust the strength/timing of inputs probably ...
sd: yeah that makes sense

** try a single sim with BBN

use this in cfg.py : 

cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat', # BBN_trials/ICoutput_CF_9600_10400_wav_BBN_100ms_burst_AN.mat', 
                   'startTime': 2500,
                   'weightE': 0.25,
                   'weightI': 0.25,
                   'probE': 0.12, 
                   'probI': 0.12,
                   'seed': 1}  # SHOULD THIS BE ZERO?                   

./myrun 48

  Done; gather time = 76.08 s.

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 241557 (1.54 Hz)
  Simulated time: 12.0 s; 48 workers
  Run time: 5834.21 s
   NGF1 : 1.696 Hz
   IT2 : 0.161 Hz
   SOM2 : 9.467 Hz
   PV2 : 3.583 Hz
   VIP2 : 22.328 Hz
   NGF2 : 7.775 Hz
   IT3 : 0.130 Hz
   SOM3 : 0.715 Hz
   PV3 : 2.794 Hz
   VIP3 : 10.702 Hz
   NGF3 : 4.684 Hz
   ITP4 : 0.167 Hz
   ITS4 : 0.165 Hz
   SOM4 : 0.670 Hz
   PV4 : 1.695 Hz
   VIP4 : 7.006 Hz
   NGF4 : 5.423 Hz
   IT5A : 1.077 Hz
   CT5A : 0.201 Hz
   SOM5A : 2.054 Hz
   PV5A : 0.462 Hz
   VIP5A : 2.815 Hz
   NGF5A : 5.448 Hz
   IT5B : 2.698 Hz
   CT5B : 0.058 Hz
   PT5B : 0.078 Hz
   SOM5B : 13.307 Hz
   PV5B : 0.206 Hz
   VIP5B : 1.516 Hz
   NGF5B : 4.538 Hz
   IT6 : 0.438 Hz
   CT6 : 0.294 Hz
   SOM6 : 10.228 Hz
   PV6 : 66.888 Hz
   VIP6 : 61.333 Hz
   NGF6 : 28.491 Hz
   TC : 4.613 Hz
   TCM : 4.504 Hz
   HTC : 4.200 Hz
   IRE : 2.397 Hz
   IREM : 2.975 Hz
   TI : 1.872 Hz
   TIM : 3.187 Hz
   IC : 0.242 Hz
Saving output as data/23aug24_A0/23aug24_A0_data.pkl ... 
Finished saving!
  Done; saving time = 31.39 s.

* 23aug25
** 23aug24_A0 -- check BBN sim

python -i simdat.py

NGF1 1.68 Hz
IT2 0.16 Hz
SOM2 9.57 Hz
PV2 3.66 Hz
VIP2 22.55 Hz
NGF2 7.2 Hz
IT3 0.13 Hz
SOM3 0.72 Hz
PV3 2.79 Hz
VIP3 10.64 Hz
NGF3 4.68 Hz
ITP4 0.17 Hz
ITS4 0.16 Hz
SOM4 0.66 Hz
PV4 1.71 Hz
VIP4 7.05 Hz
NGF4 5.53 Hz
IT5A 0.97 Hz
CT5A 0.12 Hz
SOM5A 2.03 Hz
PV5A 0.45 Hz
VIP5A 2.39 Hz
NGF5A 5.29 Hz
IT5B 2.69 Hz
CT5B 0.06 Hz
PT5B 0.08 Hz
SOM5B 13.16 Hz
PV5B 0.19 Hz
VIP5B 1.26 Hz
NGF5B 4.43 Hz
IT6 0.4 Hz
CT6 0.25 Hz
SOM6 9.94 Hz
PV6 67.26 Hz
VIP6 57.13 Hz
NGF6 28.51 Hz
TC 4.48 Hz
TCM 4.47 Hz
HTC 4.07 Hz
IRE 2.37 Hz
IREM 2.93 Hz
TI 1.87 Hz
TIM 3.18 Hz
IC 0.24 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23aug25__rast.png]]

xlim((2e3,4e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23aug25__rastB.png]]

only looks like one activation of IC population ... 
even during that activation, do not see much impact on L4 ... 

check the parameters for IC -> THAL and THAL -> CTX

looks like it's only applied a single time at 2.5 s ... 

cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat', # BBN_trials/ICoutput_CF_9600_10400_wav_BBN_100ms_burst_AN.mat', 
                   'startTime': 2500,
                   'weightE': 0.25,
                   'weightI': 0.25,
                   'probE': 0.12, 
                   'probI': 0.12,
                   'seed': 1}  # SHOULD THIS BE ZERO?                   

moved params into cfg.py ... 

  Spikes: 262669 (1.67 Hz)
  Simulated time: 12.0 s; 48 workers
  Run time: 5662.20 s
   NGF1 : 1.714 Hz
   IT2 : 0.160 Hz
   SOM2 : 9.700 Hz
   PV2 : 3.032 Hz
   VIP2 : 16.359 Hz
   NGF2 : 7.000 Hz
   IT3 : 0.115 Hz
   SOM3 : 0.715 Hz
   PV3 : 2.851 Hz
   VIP3 : 8.468 Hz
   NGF3 : 4.515 Hz
   ITP4 : 0.135 Hz
   ITS4 : 0.158 Hz
   SOM4 : 0.678 Hz
   PV4 : 2.138 Hz
   VIP4 : 5.532 Hz
   NGF4 : 5.167 Hz
   IT5A : 1.002 Hz
   CT5A : 0.202 Hz
   SOM5A : 1.754 Hz
   PV5A : 0.458 Hz
   VIP5A : 2.815 Hz
   NGF5A : 5.146 Hz
   IT5B : 2.198 Hz
   CT5B : 0.082 Hz
   PT5B : 0.080 Hz
   SOM5B : 12.832 Hz
   PV5B : 0.209 Hz
   VIP5B : 1.495 Hz
   NGF5B : 4.028 Hz
   IT6 : 0.547 Hz
   CT6 : 0.294 Hz
   SOM6 : 10.343 Hz
   PV6 : 86.855 Hz
   VIP6 : 79.076 Hz
   NGF6 : 29.401 Hz
   TC : 5.033 Hz
   TCM : 4.918 Hz
   HTC : 4.716 Hz
   IRE : 2.494 Hz
   IREM : 2.955 Hz
   TI : 1.795 Hz
   TIM : 3.070 Hz
   IC : 3.392 Hz
Saving output as data/23aug24_BBN0/23aug24_BBN0_data.pkl ... 

* 23aug30 - adjusting for BBN
** check output from 23aug24_BBN0

python -i simdat.py 23aug24_BBN0

loaded simulation data 23aug24_BBN0 on 23aug30_
NGF1 1.69 Hz
IT2 0.16 Hz
SOM2 9.8 Hz
PV2 3.1 Hz
VIP2 16.45 Hz
NGF2 6.48 Hz
IT3 0.11 Hz
SOM3 0.72 Hz
PV3 2.85 Hz
VIP3 8.4 Hz
NGF3 4.51 Hz
ITP4 0.13 Hz
ITS4 0.16 Hz
SOM4 0.66 Hz
PV4 2.14 Hz
VIP4 5.55 Hz
NGF4 5.27 Hz
IT5A 0.9 Hz
CT5A 0.12 Hz
SOM5A 1.73 Hz
PV5A 0.45 Hz
VIP5A 2.39 Hz
NGF5A 4.98 Hz
IT5B 2.19 Hz
CT5B 0.08 Hz
PT5B 0.08 Hz
SOM5B 12.68 Hz
PV5B 0.2 Hz
VIP5B 1.24 Hz
NGF5B 3.9 Hz
IT6 0.51 Hz
CT6 0.25 Hz
SOM6 10.05 Hz
PV6 87.41 Hz
VIP6 73.74 Hz
NGF6 29.44 Hz
TC 4.89 Hz
TCM 4.89 Hz
HTC 4.58 Hz
IRE 2.46 Hz
IREM 2.91 Hz
TI 1.79 Hz
TIM 3.06 Hz
IC 3.38 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23aug30_23aug24_BBN0_rast.png]]

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23aug30_23aug24_BBN0_rastB.png]]

does not look like any increase in L4 during the BBNs ... compared to the version
used in paper, so params must still differ

lk = ['IC', 'TC', 'TCM', 'ITP4','ITS4']
lclr = ['r','g','b','c','m']
sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 12e3) for k in lk}

for k,clr in zip(lk, lclr): plot(sh[k][0],sh[k][1],clr)
xlim((4e3,6e3))
ax=gca()
lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehist.png') # [[./gif/23aug30_23aug24_BBN0_spikehist.png]]

so IC, TC, TCM rates are increasing, but not L4 ITP4, ITS4 (L4 pyramidal and stellate neurons)

xlim((4e3,8e3))

savefig(gifpath()+'_spikehistB.png') # [[./gif/23aug30_23aug24_BBN0_spikehistB.png]]

so params used must not be correct ... 

** discuss

sn: those params i mentioned above must be incorrect, since look pretty different in terms of responses to BBN (almost negligible in L4)
[[./gif/23aug30_23aug24_BBN0_rast.png]]
[[./gif/23aug30_23aug24_BBN0_rastB.png]]
[[./gif/23aug30_23aug24_BBN0_spikehistB.png]]
sd: not sure if params right, but unfortunately there’s not much L4 activity in BBN sims… not sure if due to depol block
sn: i should prob. start from ones used in paper
that one had more noticeable response in L4
sd: above was referring to paper sims, not much L4 activity either
sn: so as long as maintain physiological firing rates during spontaneous and stimulation, tweaking thalamocortical and
corticothalamic gain within ~25% range reasonable?
will try that or something similar
sd: yeah I think reasonable ... can play with IC->Thal and Thal->Cx prob conn and weights

** adjust conn/weights for getting stronger BBN response

some of the relevant parameters:
    # params[('ICThalInput', 'probE')] = [0.12, 0.26]     # [0.26]    # 0,1,2  
    # params[('ICThalInput', 'probI')] = [0.12, 0.26]                 # 0,1,2
    #params[('ICThalInput', 'weightE')] = [0.25, 0.5]
    #params[('ICThalInput', 'weightI')] = [0.25, 0.5]

values used in previous simulation (23aug24_BBN0_):
                            'weightE': 0.25,
                            'weightI': 0.25,
                            'probE': 0.12, 
                            'probI': 0.12,

here are the other params taken from the json file (data/v34_batch25/trial_2142/trial_2142_cfg.json):
    updateParams2 = ['thalamoCorticalGain', 'intraThalamicGain', 'EbkgThalamicGain', 'IbkgThalamicGain', 'wmat']

        "thalamoCorticalGain": 2.1111391118965863,
        "intraThalamicGain": 0.9843624229766335,
        "EbkgThalamicGain": 3.9181565363409163,
        "IbkgThalamicGain": 3.9227144872233324,

and the whole wmat is also specified in json ... 

also, the json file was already getting loaded, so did not need the extra function to 'load from batch' config

easiest to just change IC -> Thal, that way spontaneous dynamics do not require retuning

*** 23aug30_BBN_A0

weightE = 0.375, weightI = 0.25, probE = 0.19, probI = 0.12

./myrun 48

  Spikes: 268783 (1.71 Hz)
  Simulated time: 12.0 s; 48 workers
  Run time: 9613.97 s
   NGF1 : 1.707 Hz
   IT2 : 0.160 Hz
   SOM2 : 9.633 Hz
   PV2 : 3.128 Hz
   VIP2 : 15.802 Hz
   NGF2 : 6.925 Hz
   IT3 : 0.112 Hz
   SOM3 : 0.715 Hz
   PV3 : 3.202 Hz
   VIP3 : 8.334 Hz
   NGF3 : 4.535 Hz
   ITP4 : 0.134 Hz
   ITS4 : 0.149 Hz
   SOM4 : 0.663 Hz
   PV4 : 2.853 Hz
   VIP4 : 5.679 Hz
   NGF4 : 5.155 Hz
   IT5A : 0.962 Hz
   CT5A : 0.202 Hz
   SOM5A : 1.716 Hz
   PV5A : 0.468 Hz
   VIP5A : 3.019 Hz
   NGF5A : 5.104 Hz
   IT5B : 2.301 Hz
   CT5B : 0.113 Hz
   PT5B : 0.071 Hz
   SOM5B : 13.554 Hz
   PV5B : 0.207 Hz
   VIP5B : 2.047 Hz
   NGF5B : 3.962 Hz
   IT6 : 0.541 Hz
   CT6 : 0.292 Hz
   SOM6 : 10.314 Hz
   PV6 : 88.349 Hz
   VIP6 : 83.212 Hz
   NGF6 : 29.702 Hz
   TC : 5.342 Hz
   TCM : 5.195 Hz
   HTC : 5.041 Hz
   IRE : 2.679 Hz
   IREM : 3.188 Hz
   TI : 1.672 Hz
   TIM : 2.897 Hz
   IC : 3.392 Hz

*** 23aug30_BBN_B0

weightE = 0.375, weightI = 0.375, probE = 0.19, probI = 0.19

./myrun 48

  Spikes: 289178 (1.84 Hz)
  Simulated time: 12.0 s; 48 workers
  Run time: 9605.40 s
   NGF1 : 1.736 Hz
   IT2 : 0.160 Hz
   SOM2 : 9.517 Hz
   PV2 : 3.032 Hz
   VIP2 : 15.990 Hz
   NGF2 : 6.650 Hz
   IT3 : 0.101 Hz
   SOM3 : 0.715 Hz
   PV3 : 4.125 Hz
   VIP3 : 7.869 Hz
   NGF3 : 4.456 Hz
   ITP4 : 0.117 Hz
   ITS4 : 0.138 Hz
   SOM4 : 0.663 Hz
   PV4 : 4.173 Hz
   VIP4 : 6.128 Hz
   NGF4 : 5.077 Hz
   IT5A : 0.873 Hz
   CT5A : 0.204 Hz
   SOM5A : 1.661 Hz
   PV5A : 0.514 Hz
   VIP5A : 3.315 Hz
   NGF5A : 5.052 Hz
   IT5B : 2.402 Hz
   CT5B : 0.177 Hz
   PT5B : 0.067 Hz
   SOM5B : 14.359 Hz
   PV5B : 0.226 Hz
   VIP5B : 1.818 Hz
   NGF5B : 4.118 Hz
   IT6 : 0.559 Hz
   CT6 : 0.308 Hz
   SOM6 : 10.388 Hz
   PV6 : 102.047 Hz
   VIP6 : 87.780 Hz
   NGF6 : 30.684 Hz
   TC : 5.927 Hz
   TCM : 5.983 Hz
   HTC : 5.532 Hz
   IRE : 2.738 Hz
   IREM : 3.038 Hz
   TI : 1.672 Hz
   TIM : 2.863 Hz
   IC : 3.392 Hz

* 23aug31
** check outputs from last two sims
*** 23aug30_BBN_A0

weightE = 0.375, weightI = 0.25, probE = 0.19, probI = 0.12

python -i simdat.py 23aug30_BBN_A0

NGF1 1.69 Hz
IT2 0.16 Hz
SOM2 9.74 Hz
PV2 3.19 Hz
VIP2 15.88 Hz
NGF2 6.41 Hz
IT3 0.11 Hz
SOM3 0.72 Hz
PV3 3.2 Hz
VIP3 8.27 Hz
NGF3 4.53 Hz
ITP4 0.13 Hz
ITS4 0.15 Hz
SOM4 0.65 Hz
PV4 2.86 Hz
VIP4 5.7 Hz
NGF4 5.26 Hz
IT5A 0.86 Hz
CT5A 0.12 Hz
SOM5A 1.69 Hz
PV5A 0.46 Hz
VIP5A 2.58 Hz
NGF5A 4.94 Hz
IT5B 2.29 Hz
CT5B 0.11 Hz
PT5B 0.07 Hz
SOM5B 13.4 Hz
PV5B 0.2 Hz
VIP5B 1.77 Hz
NGF5B 3.84 Hz
IT6 0.5 Hz
CT6 0.25 Hz
SOM6 10.02 Hz
PV6 88.91 Hz
VIP6 77.61 Hz
NGF6 29.75 Hz
TC 5.2 Hz
TCM 5.17 Hz
HTC 4.9 Hz
IRE 2.65 Hz
IREM 3.14 Hz
TI 1.67 Hz
TIM 2.89 Hz
IC 3.38 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23aug31_23aug30_BBN_A0_rast.png]]

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23aug31_23aug30_BBN_A0_rastB.png]]

lk = ['IC', 'TC', 'TCM', 'IT2', 'IT3', 'ITP4','ITS4']
lclr = ['r','g','b','c','m','y','k']
sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 12e3) for k in lk}

for k,clr in zip(lk, lclr): plot(sh[k][0],sh[k][1],clr)
xlim((4e3,6e3))
ax=gca()
lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehist.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehist.png]]

xlim((4e3,8e3))

savefig(gifpath()+'_spikehistB.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistB.png]]

put thal, ctx hist in diff subplots

lplt = [1,1,1,2,2,2,2]

for k,clr,gdx in zip(lk, lclr,lplt): 
  subplot(2,1,gdx)
  plot(sh[k][0],sh[k][1],clr)

ax=subplot(2,1,1)
lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr[0:3],lk[0:3])]
ax.legend(handles=lpatch,handlelength=1)
ax=subplot(2,1,2)
lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr[3:],lk[3:])]
ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehistC.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistC.png]]

ylim((0,.65))
savefig(gifpath()+'_spikehistD.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistD.png]]

looks like IT3 increases slightly for some of the stimuli, while other E neurons decrease
activation during stimulus, due to activation of interneurons ... 

dnumc
{'NGF1': 150, 'IT2': 338, 'SOM2': 5, 'PV2': 13, 'VIP2': 16, 'NGF2': 11, 'IT3': 4461, 'SOM3': 70, 'PV3': 176, 'VIP3': 211, 'NGF3': 150, 'ITP4': 837, 'ITS4': 837, 'SOM4': 24, 'PV4': 92, 'VIP4': 13, 'NGF4': 14, 'IT5A': 359, 'CT5A': 359, 'SOM5A': 43, 'PV5A': 73, 'VIP5A': 10, 'NGF5A': 8, 'IT5B': 471, 'CT5B': 471, 'PT5B': 471, 'SOM5B': 112, 'PV5B': 134, 'VIP5B': 17, 'NGF5B': 24, 'IT6': 1009, 'CT6': 1009, 'SOM6': 63, 'PV6': 84, 'VIP6': 12, 'NGF6': 38, 'TC': 116, 'TCM': 155, 'HTC': 38, 'IRE': 155, 'IREM': 155, 'TI': 51, 'TIM': 51, 'IC': 200}

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 12e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 12e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 12e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']
sh['ICTX'] = sh[k]

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehistE.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistE.png]]

subplot(3,1,2); ylim((0,.35)); subplot(3,1,3); ylim((1,7))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistF.png]]

for gdx in [1,2,3]: subplot(3,1,gdx); xlim((3e3,11e3))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23sep7_23aug30_BBN_A0_spikehistG.png]]

so does look like inhib ramping up during stimulus ... check next simulation with diff params

*** 23aug30_BBN_B0

weightE = 0.375, weightI = 0.375, probE = 0.19, probI = 0.19

python -i simdat.py 23aug30_BBN_B0

NGF1 1.72 Hz
IT2 0.16 Hz
SOM2 9.62 Hz
PV2 3.1 Hz
VIP2 16.07 Hz
NGF2 6.15 Hz
IT3 0.1 Hz
SOM3 0.72 Hz
PV3 4.12 Hz
VIP3 7.8 Hz
NGF3 4.45 Hz
ITP4 0.12 Hz
ITS4 0.14 Hz
SOM4 0.65 Hz
PV4 4.16 Hz
VIP4 6.15 Hz
NGF4 5.18 Hz
IT5A 0.77 Hz
CT5A 0.12 Hz
SOM5A 1.64 Hz
PV5A 0.51 Hz
VIP5A 2.85 Hz
NGF5A 4.88 Hz
IT5B 2.39 Hz
CT5B 0.18 Hz
PT5B 0.07 Hz
SOM5B 14.2 Hz
PV5B 0.22 Hz
VIP5B 1.55 Hz
NGF5B 4.0 Hz
IT6 0.52 Hz
CT6 0.27 Hz
SOM6 10.1 Hz
PV6 102.74 Hz
VIP6 81.89 Hz
NGF6 30.75 Hz
TC 5.78 Hz
TCM 5.96 Hz
HTC 5.39 Hz
IRE 2.71 Hz
IREM 2.99 Hz
TI 1.67 Hz
TIM 2.85 Hz
IC 3.38 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23sep7_23aug30_BBN_B0_rast.png]]

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23sep7_23aug30_BBN_B0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 12e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 12e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 12e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']
sh['ICTX'] = sh[k]

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)

savefig(gifpath()+'_spikehistE.png') # [[./gif/23sep7_23aug30_BBN_B0_spikehistE.png]]

subplot(3,1,2); ylim((0,.35)); subplot(3,1,3); ylim((1,7))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23sep7_23aug30_BBN_B0_spikehistF.png]]

for gdx in [1,2,3]: subplot(3,1,gdx); xlim((3e3,11e3))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23sep7_23aug30_BBN_B0_spikehistG.png]]

during stimulus looks like even less ECTX firing here, but more synchronized, partly through
higher inhibition

* 23sep7
** next simulations (less inhib from IC -> Thal)

hmm, that may not help since thalamus to cortex is the current issue leading
to too much cortical inhibition activated ... adjusting thalamic to cortical
drive for E vs I will cause changes in spontaneous activity

ran before: 
 23aug30_BBN_A0 : weightE = 0.375, weightI = 0.25, probE = 0.19, probI = 0.12
 23aug30_BBN_B0 : weightE = 0.375, weightI = 0.375, probE = 0.19, probI = 0.19
both had too much cortical inhibition activated ... ? 

some parameters that may need adjustment:
cfg.EbkgThalamicGain = 4.0
cfg.IbkgThalamicGain = 4.0

cfg.thalamoCorticalGain = 1.0
cfg.intraThalamicGain = 1.0
cfg.corticoThalamicGain = 1.0

also TC and TCM should probably get activated differently from IC inputs
so may need to add separate gain factor for IC -> TC and IC -> TCM 

*** 23sep7_BBN_A0
*** 23sep7_BBN_B0
* 23oct6 - BBN ERPs
** opt for BBN

to start, can use avg CSD BBN ERP response in each layer

from NHP : /data/samn/a1dat/data/bbn/avgERP/19aug23_50dB_bbn_avgERP.pkl

python

import numpy as np
import pickle
d = pickle.load(open('/data/samn/a1dat/data/bbn/avgERP/19aug23_50dB_bbn_avgERP.pkl','rb'))
d.keys() # dict_keys([44000.0, 20000.0])

type(d[44000.0]['CSD'])
d[44000.0]['CSD'].keys() # dict_keys(['A1', 'Thal', 'Empty'])
d[44000.0]['CSD']['A1'].keys() # dict_keys(['s2', 'g', 'i1', 'tt', 's2avg', 's2stderr', 'gavg', 'gstderr', 'i1avg', 'i1stderr'])

for k in ['s2avg', 'gavg', 'i1avg']: plot(d[44000.0]['CSD']['A1']['tt'], d[44000.0]['CSD']['A1'][k])

savefig('gif/23oct6_nhp_avg_csd_bbn_erp_a0.png') # [[./gif/23oct6_nhp_avg_csd_bbn_erp_a0.png]]

looks much different from ERPs in
 https://docs.google.com/presentation/d/1fBufKJtZsNOOGMmcXCTHjgU7cZlPMJFqPwm0hVfBPjw/edit#slide=id.g278ae243da3_0_84
slide 28

which CSD channels used in A1 model for s, g, i layers?

* 23oct31 - continue check BBN ERPs
** back to BBN ERP opt

d[44000.0]['CSD']['A1']['tt'][0] # 0.0
d[44000.0]['CSD']['A1']['tt'][-1] # 150.0

so 150 ms for the NHP ERP averages in s,g,i layers

info from EG:
https://docs.google.com/document/d/1E0EHdja1HpzQKHa0q5WqGRP386xjEYs_wHDLz2xanLI/edit
https://github.com/NathanKlineInstitute/a1dat/blob/erica/avgERP_forPaper.py

looks like the ERPs are smoothed using bandpass filter of 1-110 Hz
and in slides/A1 paper, used 300 ms instead of 150 ms used in OEvent paper

figure()

for k,clr in zip(['s2avg', 'gavg', 'i1avg'],['r','g','b']): plot(d[44000.0]['CSD']['A1']['tt'], bandpass(d[44000.0]['CSD']['A1'][k],1,110,44000),clr)

savefig('gif/23oct31_nhp_avg_csd_bbn_erp_smoothed_a0.png') # [[./gif/23oct31_nhp_avg_csd_bbn_erp_smoothed_a0.png

dERPLowPass = {}
for k in ['s2avg', 'gavg', 'i1avg']: dERPLowPass[k] = bandpass(d[44000.0]['CSD']['A1'][k],1,110,44000)
pickle.dump(dERPLowPass,open('/data/samn/a1dat/data/bbn/avgERP/23nov1_50dB_bbn_avgERP_bandpass_1_110_Hz.pkl','wb'))
ok, will use that file for optimization/comparison with model

* 23nov1 - looking at BBN ERPs: model vs nhp
** model channels for s, g, i = 4, 10, 15

	## Get channel(s) to plot
		if region == 'supra':
			chan = 4 # chan 0-9
		elif region == 'gran':
			chan = 10  # chan 10-11
		elif region == 'infra':
			chan = 15	# chan 12-19

4, 10, 15

** extract model ERPs from BBN sim

from cfg.py can see when the BBN stimuli applied:
cfg.ICThalInput = {'file': 'data/ICoutput/ICoutput_CF_5256_6056_wav_BBN_100ms_burst.mat', # BBN_trials/ICoutput_CF_9600_10400_wav_BBN_100ms_burst_AN.mat', 
                   'startTime': list(np.arange(5000, 9000, 300)),
                   'weightE': 0.375,
                   'weightI': 0.375,
                   'probE': 0.19, 
                   'probI': 0.19,
                   'seed': 1}  # SHOULD THIS BE ZERO?                   

from 5 - 9 s interval of 300 ms between, and each BBN is 100 ms

conda activate py376

python -i simdat.py 23aug30_BBN_B0

loading data from 23aug30_BBN_B0
loaded simulation data 23aug30_BBN_B0 on 23nov1_
NGF1 1.72 Hz
IT2 0.16 Hz
SOM2 9.62 Hz
PV2 3.1 Hz
VIP2 16.07 Hz
NGF2 6.15 Hz
IT3 0.1 Hz
SOM3 0.72 Hz
PV3 4.12 Hz
VIP3 7.8 Hz
NGF3 4.45 Hz
ITP4 0.12 Hz
ITS4 0.14 Hz
SOM4 0.65 Hz
PV4 4.16 Hz
VIP4 6.15 Hz
NGF4 5.18 Hz
IT5A 0.77 Hz
CT5A 0.12 Hz
SOM5A 1.64 Hz
PV5A 0.51 Hz
VIP5A 2.85 Hz
NGF5A 4.88 Hz
IT5B 2.39 Hz
CT5B 0.18 Hz
PT5B 0.07 Hz
SOM5B 14.2 Hz
PV5B 0.22 Hz
VIP5B 1.55 Hz
NGF5B 4.0 Hz
IT6 0.52 Hz
CT6 0.27 Hz
SOM6 10.1 Hz
PV6 102.74 Hz
VIP6 81.89 Hz
NGF6 30.75 Hz
TC 5.78 Hz
TCM 5.96 Hz
HTC 5.39 Hz
IRE 2.71 Hz
IREM 2.99 Hz
TI 1.67 Hz
TIM 2.85 Hz
IC 3.38 Hz

next, get the LFP and derived CSD

simConfig['simData'].keys() # dict_keys(['LFP', 'spkt', 'spkid', 't', 'popRates', 'avgRate'])
LFP = simConfig['simData']['LFP']
len(LFP) # 240000

len(LFP[0]) # 20 <- 20 channels

LFP = np.array(LFP)
LFP.shape # (240000, 20)

tt = linspace(0,12e3,LFP.shape[0])
plot(tt,LFP[:,0])
xlabel('Time (ms)'); 

savefig('gif/23nov1_LFP_a0.png') # [[./gif/23nov1_LFP_a0.png]]

ylim((-.4,-0.05)); xlim((2e3,12e3))
savefig('gif/23nov1_LFP_a1.png') # [[./gif/23nov1_LFP_a1.png]]

CSD = getCSD(LFP, 1e3/0.05)

CSD.shape # (18, 240000)

plot(tt,CSD[0,:])
xlim((0,12e3))
savefig('gif/23nov1_CSD_a2.png') # [[./gif/23nov1_CSD_a2.png]]
ylim((-30,30))
savefig('gif/23nov1_CSD_a3.png') # [[./gif/23nov1_CSD_a3.png]]

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)
ylim((-20,20))
xlim((2e3,12e3))

savefig('gif/23nov1_CSD_a4.png') # [[./gif/23nov1_CSD_a4.png]]

xlim((4e3,10e3))

savefig('gif/23nov1_CSD_a5.png') # [[./gif/23nov1_CSD_a5.png]]

now average the CSD ERPs ... take from BBN onset + 150 ms 

bbnT = np.arange(5000, 9000, 300)
array([5000, 5300, 5600, 5900, 6200, 6500, 6800, 7100, 7400, 7700, 8000,
       8300, 8600, 8900])

use modified code from a1dat/erp.py for cutting out the ERPs and averaging them... 

CSD.shape # (18, 240000)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,bandpass(avgERP[chan,:],1,110,sampr),clr)

xlabel('Time (ms)');
xlim((0,150))


savefig('gif/23nov1_model_CSD_ERP_avg_bandpass_a6.png') # [[./gif/23nov1_model_CSD_ERP_avg_bandpass_a6.png]]

now overlay for each channel ... model and NHP average (and filtered) ERPs

import pickle

d = pickle.load(open('/data/samn/a1dat/data/bbn/avgERP/23nov1_50dB_bbn_avgERP_bandpass_1_110_Hz.pkl','rb'))

will also have to resample the data before running optimization 

ttnhpERP = np.linspace(0,150,len(d['s2avg']))

for clr,gdx,k in zip(['r','g','b'],[1,2,3],['s2avg','gavg','i1avg']):
  subplot(1,3,gdx)
  plot(ttnhpERP,d[k]/np.sum(d[k]),clr,linewidth=4)

for clr,gdx,chan in zip(['r','g','b'],[1,2,3],lchan): 
  subplot(1,3,gdx)
  y = bandpass(avgERP[chan,:],1,110,sampr)
  y = y / np.sum(y)
  plot(ttERP,y,clr)
  xlim((0,150))

savefig('gif/23nov1_model_nhp_CSD_ERP_avg_bandpass_compare_a7.png')
[[./gif/23nov1_model_nhp_CSD_ERP_avg_bandpass_compare_a7.png]]

look very different ... (thick lines are NHP, thin lines are model)

note that amplitudes are normalized ... 

** cmetzner version: https://github.com/ChristophMetzner/A1model/blob/main/batch_tu_mpi_ASSR.py

has some code for modifying the thal -> cx weights specific for E vs I inputs
cm thought could be too much activation of cx L4 I neurons by thal, while sd
though could be depolarization blockade of L4 E neurons ... so running different
grid searches to test 

cm has setup these params for modulation (thal -> cx at finer specificity):
 https://github.com/ChristophMetzner/A1model/blob/main/netParams_ASSR.py

** need to setup opt in optunaERP function in batch.py
* 23nov2 - more setup for ERP opt
** IC -> Thal, only seems to go to core

    if cfg.ICThalInput:
        netParams.connParams['IC->ThalE'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probE'],
            'weight': cfg.ICThalInput['weightE'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalI'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['RE', 'TI']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probI'],
            'weight': cfg.ICThalInput['weightI'],
            'delay': cfg.delayBkg}  

do not see projections to thalamic matrix

** add IC->Thal cfg params

# these params control IC -> Thal
cfg.ICThalweightE = 0.375
cfg.ICThalweightI = 0.375
cfg.ICThalprobE = 0.19
cfg.ICThalprobI = 0.19

** sm suggests thalL4E==0.5 to avoid dep blockade
** next BBN sim (23nov2_BBN_A0)

# these params control IC -> Thal
cfg.ICThalweightE = 0.375
cfg.ICThalweightI = 0.25
cfg.ICThalprobE = 0.19
cfg.ICThalprobI = 0.12

# these params added from Christoph Metzner branch
cfg.thalL4PV = 0.75 # [minF,maxF] 0.1 - 2
cfg.thalL4SOM = 0.75 # [minF,maxF]
cfg.thalL4E = 0.5 # [minF,maxF]

want to reduce thalamic triggered cortical inhibition,
but also reduce potential for L4 E depolarization blockade

also shortening sim duration (11 s) and start BBN at 3 s instead of 4

./myrun 48

  Spikes: 231225 (1.60 Hz)
  Simulated time: 11.0 s; 48 workers
  Run time: 5049.40 s
   NGF1 : 1.796 Hz
   IT2 : 0.019 Hz
   SOM2 : 7.000 Hz
   PV2 : 0.469 Hz
   VIP2 : 14.545 Hz
   NGF2 : 6.636 Hz
   IT3 : 0.111 Hz
   SOM3 : 0.038 Hz
   PV3 : 2.938 Hz
   VIP3 : 7.051 Hz
   NGF3 : 4.377 Hz
   ITP4 : 0.009 Hz
   ITS4 : 0.036 Hz
   SOM4 : 0.012 Hz
   PV4 : 0.716 Hz
   VIP4 : 7.084 Hz
   NGF4 : 4.383 Hz
   IT5A : 0.941 Hz
   CT5A : 0.301 Hz
   SOM5A : 0.820 Hz
   PV5A : 0.573 Hz
   VIP5A : 3.525 Hz
   NGF5A : 5.386 Hz
   IT5B : 2.236 Hz
   CT5B : 0.124 Hz
   PT5B : 0.082 Hz
   SOM5B : 13.158 Hz
   PV5B : 0.246 Hz
   VIP5B : 1.915 Hz
   NGF5B : 4.538 Hz
   IT6 : 0.239 Hz
   CT6 : 0.163 Hz
   SOM6 : 6.456 Hz
   PV6 : 94.373 Hz
   VIP6 : 85.612 Hz
   NGF6 : 18.388 Hz
   TC : 5.696 Hz
   TCM : 5.419 Hz
   HTC : 5.064 Hz
   IRE : 2.597 Hz
   IREM : 3.113 Hz
   TI : 1.678 Hz
   TIM : 2.916 Hz
   IC : 3.701 Hz
Saving output as data/23nov2_BBN_A0/23nov2_BBN_A0_data.pkl ... 

** setting up optuna ERP optimization

need to have the NHP data at 20 kHz ... 

that's sampling rate used in model

python

import numpy as np
import pickle
d = pickle.load(open('/data/samn/a1dat/data/bbn/avgERP/19aug23_50dB_bbn_avgERP.pkl','rb'))
d.keys() # dict_keys([44000.0, 20000.0])

so have 20 kHz data ... just need to smooth it 1-110 Hz for use in opt

dERPLowPass = {20000:{},44000:{}}
for sampr in [20000, 44000]:
  for k in ['s2avg', 'gavg', 'i1avg']: dERPLowPass[sampr][k] = bandpass(d[sampr]['CSD']['A1'][k],1,110,sampr)

for gdx,sampr in zip([1,2],[20000, 44000]):
  subplot(1,2,gdx); title(str(sampr)+' Hz')
  ttnhpERP = np.linspace(0,150,len(dERPLowPass[sampr]['s2avg']))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, dERPLowPass[sampr][k],clr)
  xlabel('Time (ms)'); xlim((0,150))

savefig('gif/23nov2_nhp_erp_20khz_a0.png') # [[./gif/23nov2_nhp_erp_20khz_a0.png]]

savefig('gif/23nov2_nhp_erp_20khz_44kHz_a1.png') # [[./gif/23nov2_nhp_erp_20khz_44kHz_a1.png]]

looks much different with the 20 kHz vs 44 kHz ... 

also try w/o the bandpass filtering ... 

for gdx,sampr in zip([1,2],[20000, 44000]):
  subplot(1,2,gdx); title(str(sampr)+' Hz')
  ttnhpERP = np.linspace(0,150,len(dERPLowPass[sampr]['s2avg']))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, dERPLowPass[sampr][k],clr,linewidth=4)
  xlabel('Time (ms)'); xlim((0,150))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, d[sampr]['CSD']['A1'][k],clr)

savefig('gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_a2.png') # [[./gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_a2.png]]

timing of ERP features is very distorted with the bandpass filter 1-110 Hz ... 

minf,maxf=1,1000
dERPLowPass = {20000:{},44000:{}}
for sampr in [20000, 44000]:
  for k in ['s2avg', 'gavg', 'i1avg']: dERPLowPass[sampr][k] = bandpass(d[sampr]['CSD']['A1'][k],minf,maxf,sampr)

for gdx,sampr in zip([1,2],[20000, 44000]):
  subplot(1,2,gdx); title(str(sampr)+' Hz')
  ttnhpERP = np.linspace(0,150,len(dERPLowPass[sampr]['s2avg']))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, dERPLowPass[sampr][k],clr,linewidth=4)
  xlabel('Time (ms)'); xlim((0,150))
  for clr,k in zip(['r','g','b'],['s2avg', 'gavg', 'i1avg']): plot(ttnhpERP, d[sampr]['CSD']['A1'][k],clr)

savefig('gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_1_1000_Hz_a3.png') # [[./gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_1_1000_Hz_a3.png]]

better with the higher upper maxf of 1 kHz but still introduces some distortion to the ERPs ... will not smooth
them for the optimization ... and probably better to use the 44 kHz vs 20 kHz ... 

## pickle.dump(dERPLowPass,open('/data/samn/a1dat/data/bbn/avgERP/23nov2_50dB_bbn_avgERP_bandpass_1_110_Hz_20kHz_rate.pkl','wb'))

** check output from 23nov2_BBN_A0

python -i simdat.py 23nov2_BBN_A0

NGF1 1.78 Hz
IT2 0.02 Hz
SOM2 7.07 Hz
PV2 0.48 Hz
VIP2 14.62 Hz
NGF2 6.16 Hz
IT3 0.11 Hz
SOM3 0.04 Hz
PV3 2.94 Hz
VIP3 6.99 Hz
NGF3 4.38 Hz
ITP4 0.01 Hz
ITS4 0.04 Hz
SOM4 0.01 Hz
PV4 0.72 Hz
VIP4 7.13 Hz
NGF4 4.48 Hz
IT5A 0.83 Hz
CT5A 0.21 Hz
SOM5A 0.8 Hz
PV5A 0.57 Hz
VIP5A 3.05 Hz
NGF5A 5.24 Hz
IT5B 2.23 Hz
CT5B 0.12 Hz
PT5B 0.08 Hz
SOM5B 13.03 Hz
PV5B 0.24 Hz
VIP5B 1.64 Hz
NGF5B 4.41 Hz
IT6 0.21 Hz
CT6 0.12 Hz
SOM6 6.23 Hz
PV6 95.13 Hz
VIP6 79.97 Hz
NGF6 18.26 Hz
TC 5.58 Hz
TCM 5.4 Hz
HTC 4.94 Hz
IRE 2.57 Hz
IREM 3.07 Hz
TI 1.68 Hz
TIM 2.91 Hz
IC 3.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23nov2_23nov2_BBN_A0_rast.png]]

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23nov2_23nov2_BBN_A0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 11e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']
sh['ICTX'] = sh[k]

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

savefig(gifpath()+'_spikehistE.png') # [[./gif/23nov2_23nov2_BBN_A0_spikehistE.png]]

subplot(3,1,2); ylim((0,.35)); subplot(3,1,3); ylim((1,7))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23nov2_23nov2_BBN_A0_spikehistF.png]]

for gdx in [1,2,3]: subplot(3,1,gdx); xlim((3e3,11e3))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov2_23nov2_BBN_A0_spikehistG.png]]

during BBN inputs still see the TC and TCM populations getting activated ~equally ... 
that should be checked/fixed!

also looks like L4 E neurons are still not getting activated enough

check CSD ERPs ... 

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)

tt = linspace(0,totalDur,LFP.shape[0])

CSD = getCSD(LFP, 1e3/0.05)

CSD.shape # (18, 220000)

plot(tt,CSD[0,:])
xlim((0,totalDur))
savefig('gif/23nov2_CSD_a2.png') #

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)
ylim((-20,20))
xlim((2e3,totalDur))

savefig('gif/23nov2_CSD_a4.png') # [[./gif/23nov2_CSD_a4.png]]

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig('gif/23nov2_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov2_model_BBN_avg_ERP_CSD_a5.png]]

so, probably firing activity should get adjusted ... then CSD opt ...

drawcellVm(simConfig) # did not record Vm ... 

** emails about NHP ERPs, recording sampling rates, and best frequencies

Hi,

I'm looking at NHP ERPs in response to BBN for optimizing the A1 model
to reproduce them. I noticed that the 20 vs 44 kHz dataset has pretty
different-looking ERPs. Do you recommend one or the other in the
attachment as prototypical ERPs to optimize towards?

I attached the average ERPs from BBN in 20 vs 44 kHz recordings. Red,
green, blue are the supra-, gran-, and infra-granular sink channel
average CSD ERP. Thick lines are also bandpass filtered between
1-1kHz, which distorts the waveforms, so will be avoided.

Thanks,
Sam

attachment: [[./gif/23nov2_nhp_erp_20khz_44kHz_smooth_no_smooth_1_1000_Hz_a3.png]]


no> Just so I’m clear at what I’m looking at, is this data in response
to BBN from an A1 site whose BF is 20KHz (left plot) and then A1 site
whose BF is 44kHz (right plot)? Although we usually don’t have BFs
that high…max is usually 32KHz…is that a typo and the 44kHz is 32kHz?

sn> No, the 20 vs 44 kHz is the .mat file recording frequency. I think
20 kHz is from older data ...

no> Oh I see….yes the 20kHz is the sampling rate of the older system.
The CSD response to BBN may depend on the BF of the recording site, as
High BF sites tend to show a better more typical response to BBN
whereas lower tuned BF sites show a much mushier response. DO you know
the BFs of these two sites?  The plots on the right (44kHz) does show
a more typical response as the gran (green) trace is a sink as it
should be, whereas in the left plot it’s a source. Honestly though the
sampling rate of the system shouldn’t affect the profiles.

sn> The 44 kHz data is the same as shown in Fig 2 here:
 https://www.eneuro.org/content/eneuro/9/4/ENEURO.0281-21.2022.full.pdf
 I can go with that if you think it's OK, but If you know of an ideal
 example of s,g,i CSD ERP response to BBN I should probably use that
 instead of mixing together data from different NHPs/BFs, even at the
 44 kHz rate.

Here are the files used and their best frequencies (last column):

2-rb019020063@os.mat sampr: 44000.0 bestF: 500.0
2-rb023024010@os.mat sampr: 44000.0 bestF: 11313.7084989848
2-rb023024011@os.mat sampr: 44000.0 bestF: 11313.7084989848
2-rb023024012@os.mat sampr: 44000.0 bestF: 11313.7084989848
2-rb023024052@os.mat sampr: 44000.0 bestF: 11313.7084989848
2-rb029030006@os.mat sampr: 44000.0 bestF: 16000.0
2-rb029030009@os.mat sampr: 44000.0 bestF: 16000.0

Should I just use the ones with 11313 and 16000 best frequencies and
leave out the first file? or even just use the last 2?

no> Yes, I would use 2-rb023024011 or 2-rb023024052, it's a beautiful
BBN related profile. Ch 11 for supra, ch 15 for gran and ch 20 for
infra.

For some reason 2-rb029030 has a very weird profile, so I wouldn't use.

** make sure IC -> TC,HTC activates separately from IC -> TCM

was looking at A1 model response to BBN and seemed that TC and TCM
neurons responded similarly ... think TCM should respond less than TC
to core-like inputs. but looking at code see the following

    # cochlea/IC -> thal
    if cfg.ICThalInput:
        netParams.connParams['IC->ThalE'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probE'],
            'weight': cfg.ICThalInput['weightE'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalI'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'cellType': ['RE', 'TI']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probI'],
            'weight': cfg.ICThalInput['weightI'],
            'delay': cfg.delayBkg}  

seems that IC only hits TC. but since TCM is defined as a TC type here:
netParams.popParams['TCM'] =    {'cellType': 'TC',  'cellModel': 'HH_reduced',  'ynormRange': layer['thal'],   'density': thalDensity} 

does that mean TCM would receive the IC inputs?

sd> ah yes, TCM will be receiving the same IC input as TC, as they are defined using the same cell type
sn> agree i should prob adjust that?
sn> will give that a try via postconds on pop instead of celltype
sd>  yeah I think makes sense
thanks
sn> putting that in samn branch

*** email NO about this

one more question

right now the model thalamic core and matrix get the same inputs from
inferior colliculus. I was thinking core-like inputs should hit
thalamic core more strongly than thalamic matrix. Do you agree?
Perhaps just down-modulating the strength of inputs to thalamic matrix
makes sense, so that some modulatory auditory stimulus component
reaches thalamic matrix, just less strongly than thalamic core. Do you
agree?

Thanks,
Sam

no> I am no expert but the matrix of MGB receives inputs from all 3 of
the IC divisions (the tonotopically organized CNIC and the other 2
non-tonotopically organized divisions) while MGBv receives inputs only
from the CNIC, so I agree that just lowering the strength of the core
like inputs to the matrix makes sense.

** make separate pathway for IC -> thalamic core and IC -> thalamic matrix (23nov2_BBN_B0)

will have weaker and lower probability of connection from IC -> Thalamic Matrix
compared to Thalamic Core

for example:

# these params control IC -> Thalamic Core
cfg.ICThalweightECore = 0.375
cfg.ICThalweightICore = 0.25
cfg.ICThalprobECore = 0.19
cfg.ICThalprobICore = 0.12
# these params control IC -> Thalamic Matrix
cfg.ICThalMatrixCoreFactor = 0.2
cfg.ICThalweightEMatrix = cfg.ICThalweightECore * cfg.ICThalMatrixCoreFactor
cfg.ICThalweightIMatrix = cfg.ICThalweightICore * cfg.ICThalMatrixCoreFactor
cfg.ICThalprobEMatrix = cfg.ICThalprobECore * cfg.ICThalMatrixCoreFactor
cfg.ICThalprobIMatrix = cfg.ICThalprobICore * cfg.ICThalMatrixCoreFactor

and then adjust netParams.py as follows:

    # cochlea/IC -> thal
    if cfg.ICThalInput:
        # IC -> thalamic core
        netParams.connParams['IC->ThalECore'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['TC', 'HTC']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probECore'],
            'weight': cfg.ICThalInput['weightECore'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalICore'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['RE', 'TI']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probICore'],
            'weight': cfg.ICThalInput['weightICore'],
            'delay': cfg.delayBkg}

        # IC -> thalamic matrix
        netParams.connParams['IC->ThalEMatrix'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['TCM']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': ESynMech,
            'probability': cfg.ICThalInput['probEMatrix'],
            'weight': cfg.ICThalInput['weightEMatrix'],
            'synMechWeightFactor': cfg.synWeightFractionEE,
            'delay': cfg.delayBkg}
        
        netParams.connParams['IC->ThalIMatrix'] = { 
            'preConds': {'pop': 'IC'}, 
            'postConds': {'pop': ['IREM', 'TIM']},
            'sec': 'soma', 
            'loc': 0.5,
            'synMech': 'GABAA',
            'probability': cfg.ICThalInput['probIMatrix'],
            'weight': cfg.ICThalInput['weightIMatrix'],
            'delay': cfg.delayBkg}  

ok, try that sim out, same as previous otherwise

also saving traces from each pop to check dep block

./myrun 48

  Simulated time: 11.0 s; 48 workers
  Run time: 5053.70 s
   NGF1 : 1.744 Hz
   IT2 : 0.020 Hz
   SOM2 : 7.945 Hz
   PV2 : 0.490 Hz
   VIP2 : 17.034 Hz
   NGF2 : 7.036 Hz
   IT3 : 0.127 Hz
   SOM3 : 0.038 Hz
   PV3 : 2.057 Hz
   VIP3 : 7.942 Hz
   NGF3 : 4.438 Hz
   ITP4 : 0.013 Hz
   ITS4 : 0.040 Hz
   SOM4 : 0.012 Hz
   PV4 : 0.462 Hz
   VIP4 : 7.378 Hz
   NGF4 : 4.461 Hz
   IT5A : 1.138 Hz
   CT5A : 0.305 Hz
   SOM5A : 0.870 Hz
   PV5A : 0.547 Hz
   VIP5A : 3.192 Hz
   NGF5A : 5.739 Hz
   IT5B : 2.146 Hz
   CT5B : 0.077 Hz
   PT5B : 0.088 Hz
   SOM5B : 12.580 Hz
   PV5B : 0.247 Hz
   VIP5B : 1.858 Hz
   NGF5B : 4.591 Hz
   IT6 : 0.200 Hz
   CT6 : 0.171 Hz
   SOM6 : 6.103 Hz
   PV6 : 77.460 Hz
   VIP6 : 88.430 Hz
   NGF6 : 17.562 Hz
   TC : 5.080 Hz
   TCM : 4.228 Hz
   HTC : 4.845 Hz
   IRE : 2.739 Hz
   IREM : 2.877 Hz
   TI : 1.745 Hz
   TIM : 3.156 Hz
   IC : 3.701 Hz

* 23nov3
** check output from 23nov2_BBN_B0

python -i simdat.py 23nov2_BBN_B0

NGF1 1.73 Hz
IT2 0.02 Hz
SOM2 8.04 Hz
PV2 0.5 Hz
VIP2 17.17 Hz
NGF2 6.53 Hz
IT3 0.13 Hz
SOM3 0.04 Hz
PV3 2.06 Hz
VIP3 7.89 Hz
NGF3 4.44 Hz
ITP4 0.01 Hz
ITS4 0.04 Hz
SOM4 0.01 Hz
PV4 0.46 Hz
VIP4 7.43 Hz
NGF4 4.56 Hz
IT5A 1.02 Hz
CT5A 0.22 Hz
SOM5A 0.85 Hz
PV5A 0.54 Hz
VIP5A 2.74 Hz
NGF5A 5.6 Hz
IT5B 2.14 Hz
CT5B 0.08 Hz
PT5B 0.09 Hz
SOM5B 12.45 Hz
PV5B 0.24 Hz
VIP5B 1.59 Hz
NGF5B 4.47 Hz
IT6 0.17 Hz
CT6 0.13 Hz
SOM6 5.88 Hz
PV6 78.03 Hz
VIP6 82.61 Hz
NGF6 17.42 Hz
TC 4.96 Hz
TCM 4.2 Hz
HTC 4.72 Hz
IRE 2.71 Hz
IREM 2.83 Hz
TI 1.75 Hz
TIM 3.15 Hz
IC 3.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23nov3_23nov2_BBN_B0_rast.png]]

ITP4, ITS4 rates still too low, even during stimulus
matrix firing a little less than before

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23nov3_23nov2_BBN_B0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 11e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

savefig(gifpath()+'_spikehistE.png') # [[./gif/23nov3_23nov2_BBN_B0_spikehistE.png]]

ok, can see now that TCM (blue in top panel) is firing less than TC (green in top panel)
during the BBN stimuli

there also appears to be a little less suppression of the cortical excitatory neurons
during BBN, due to less activation of cortical interneurons

subplot(3,1,2); ylim((0,.35)); subplot(3,1,3); ylim((1,7))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23nov3_23nov2_BBN_B0_spikehistF.png]]

still need more activation of L4 excitatory neurons during stimulation

for gdx in [1,2,3]: subplot(3,1,gdx); xlim((3e3,11e3))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov3_23nov2_BBN_B0_spikehistG.png]]

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)
ylim((-20,20))
xlim((2e3,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/23nov3_23nov2_BBN_B0_CSD_a4.png]]

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov3_23nov2_BBN_B0_model_BBN_avg_ERP_CSD_a5.png]]

simConfig['simData']['V_soma'].keys()
dict_keys(['cell_0', 'cell_7393', 'cell_9948', 'cell_494', 'cell_7406', 'cell_12303', 'cell_8272', 'cell_12496', 'cell_8181', 'cell_5065', 'cell_8138', 'cell_12458', 'cell_507', 'cell_12651', 'cell_5452', 'cell_7276', 'cell_7420', 'cell_4995', 'cell_7779', 'cell_5602', 'cell_9972', 'cell_9685', 'cell_10981', 'cell_11990', 'cell_12806', 'cell_7300', 'cell_12137', 'cell_12857', 'cell_523', 'cell_9931', 'cell_12187', 'cell_8254', 'cell_9214', 'cell_9797', 'cell_12053', 'cell_12149', 'cell_534', 'cell_151', 'cell_6439', 'cell_8743', 'cell_8264', 'cell_489', 'cell_5241'])

how about neuronal Vm ...
dstartidx['ITP4'] # 5602
dstartidx['ITS4'] # 6439

subplot(1,2,1)
drawcellVm(simConfig,ldrawpop=['ITP4','ITS4']) # 
subplot(1,2,2)
drawcellVm(simConfig,ldrawpop=['PV4','SOM4','NGF4']) # 

savefig(gifpath()+'_cell_Vm_a6.png') # [[./gif/23nov3_23nov2_BBN_B0_cell_Vm_a6.png]]

ITP4, ITS4 not activated much, and does not look like depolarization blockade ... 

** next sim, increase thal activation of L4 excitatory neurons (23nov3_BBN_A0)

and decrease thal activation of L4 inhibitory neurons
cfg.thalL4PV = 0.5 # [minF,maxF] 0.1 - 2
cfg.thalL4SOM = 0.5 # [minF,maxF]
cfg.thalL4E = 2.0 # [minF,maxF]

for prob of connections of IC -> Matrix, could keep same as core, just reduce
the weights ... to ~10%

# these params control IC -> Thalamic Matrix
cfg.ICThalMatrixCoreFactor = 0.1
cfg.ICThalweightEMatrix = cfg.ICThalweightECore * cfg.ICThalMatrixCoreFactor
cfg.ICThalweightIMatrix = cfg.ICThalweightICore * cfg.ICThalMatrixCoreFactor
cfg.ICThalprobEMatrix = cfg.ICThalprobECore # * cfg.ICThalMatrixCoreFactor
cfg.ICThalprobIMatrix = cfg.ICThalprobICore # * cfg.ICThalMatrixCoreFactor

and for core have this:
# these params control IC -> Thalamic Core
cfg.ICThalweightECore = 0.375
cfg.ICThalweightICore = 0.25
cfg.ICThalprobECore = 0.19
cfg.ICThalprobICore = 0.12

cfg.simLabel = '23nov3_BBN_A0' 

./myrun 48

Analyzing...
  Cells: 13108
  Connections: 0 (0.00 per cell)
  Spikes: 562744 (3.90 Hz)
  Simulated time: 11.0 s; 48 workers
  Run time: 5360.39 s
   NGF1 : 1.482 Hz
   IT2 : 0.813 Hz
   SOM2 : 6.327 Hz
   PV2 : 29.867 Hz
   VIP2 : 23.705 Hz
   NGF2 : 17.536 Hz
   IT3 : 0.119 Hz
   SOM3 : 3.046 Hz
   PV3 : 23.542 Hz
   VIP3 : 54.117 Hz
   NGF3 : 7.738 Hz
   ITP4 : 2.098 Hz
   ITS4 : 1.841 Hz
   SOM4 : 14.957 Hz
   PV4 : 7.751 Hz
   VIP4 : 10.881 Hz
   NGF4 : 13.162 Hz
   IT5A : 1.902 Hz
   CT5A : 1.509 Hz
   SOM5A : 10.273 Hz
   PV5A : 3.660 Hz
   VIP5A : 29.545 Hz
   NGF5A : 21.034 Hz
   IT5B : 7.403 Hz
   CT5B : 0.624 Hz
   PT5B : 0.160 Hz
   SOM5B : 24.932 Hz
   PV5B : 1.554 Hz
   VIP5B : 19.551 Hz
   NGF5B : 18.697 Hz
   IT6 : 2.038 Hz
   CT6 : 2.438 Hz
   SOM6 : 71.077 Hz
   PV6 : 0.062 Hz
   VIP6 : 1.281 Hz
   NGF6 : 144.560 Hz
   TC : 6.656 Hz
   TCM : 5.969 Hz
   HTC : 5.958 Hz
   IRE : 3.645 Hz
   IREM : 3.421 Hz
   TI : 1.929 Hz
   TIM : 2.927 Hz
   IC : 3.701 Hz

check output ... 

python -i simdat.py 23nov3_BBN_A0

NGF1 1.47 Hz
IT2 0.72 Hz
SOM2 6.2 Hz
PV2 30.48 Hz
VIP2 24.07 Hz
NGF2 15.26 Hz
IT3 0.02 Hz
SOM3 2.25 Hz
PV3 22.47 Hz
VIP3 53.56 Hz
NGF3 7.19 Hz
ITP4 2.0 Hz
ITS4 1.74 Hz
SOM4 14.28 Hz
PV4 7.4 Hz
VIP4 10.34 Hz
NGF4 12.68 Hz
IT5A 1.81 Hz
CT5A 1.42 Hz
SOM5A 9.33 Hz
PV5A 3.48 Hz
VIP5A 27.02 Hz
NGF5A 20.95 Hz
IT5B 7.4 Hz
CT5B 0.56 Hz
PT5B 0.16 Hz
SOM5B 23.72 Hz
PV5B 1.45 Hz
VIP5B 18.64 Hz
NGF5B 18.42 Hz
IT6 1.52 Hz
CT6 2.26 Hz
SOM6 68.85 Hz
PV6 0.0 Hz
VIP6 1.11 Hz
NGF6 143.99 Hz
TC 6.42 Hz
TCM 5.95 Hz
HTC 5.75 Hz
IRE 3.54 Hz
IREM 3.38 Hz
TI 1.93 Hz
TIM 2.92 Hz
IC 3.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23nov3_23nov3_BBN_A0_rast.png]]

ok, now very clear firing in L2, L3, L4 excitatory neurons

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23nov3_23nov3_BBN_A0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 11e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

savefig(gifpath()+'_spikehistE.png') # [[./gif/23nov3_23nov3_BBN_A0_spikehistE.png]]

subplot(3,1,2); ylim((0,5)); subplot(3,1,3); ylim((1,35))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23nov3_23nov3_BBN_A0_spikehistF.png]]

should just show ITP4, ITS4 for the ectx ... 

lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

subplot(3,1,2); ylim((0,10)); subplot(3,1,3); ylim((1,35))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov3_23nov3_BBN_A0_spikehistG.png]]

so L4 E neurons are firing more, but cant really say it's due to stimulus
and part of that is because TC is almost always firing, so the BBN input
is not driving TC much more ... well, a little more firing in TC ... may
need to strengthen that a bit and reduce TC -> L4E a bit so that there's
a detectable response to stimulus and background L4E is a little quieter

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)

ylim((-80,80))
xlim((2e3,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/23nov3_23nov3_BBN_A0_CSD_a4.png]]
well, now granular layer (green) has much higher amplitude CSD

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov3_23nov3_BBN_A0_model_BBN_avg_ERP_CSD_a5.png]]

granular CSD ERP looks a little better ...

subplot(1,2,1)
drawcellVm(simConfig,ldrawpop=['ITP4','ITS4']) # 
subplot(1,2,2)
drawcellVm(simConfig,ldrawpop=['PV4','SOM4','NGF4']) # 

savefig(gifpath()+'_cell_Vm_a6.png') # [[./gif/23nov3_23nov3_BBN_A0_cell_Vm_a6.png]]

** next sim (23nov3_BBN_B0)

so may need to turn down cfg.thalL4E ... ? and increase IC -> TC ... ?

increase cfg.ICThalweightECore from 0.375 to 1.0
and decrease cfg.thalL4E from 2.0 to 1.0

that way TC more activated when IC firing, and L4E a little more dependent on IC->TC pathway
for activation

./myrun 48

  Simulated time: 11.0 s; 48 workers
  Run time: 5369.96 s
   NGF1 : 1.563 Hz
   IT2 : 0.126 Hz
   SOM2 : 3.091 Hz
   PV2 : 2.105 Hz
   VIP2 : 20.756 Hz
   NGF2 : 8.264 Hz
   IT3 : 0.163 Hz
   SOM3 : 1.784 Hz
   PV3 : 5.172 Hz
   VIP3 : 11.213 Hz
   NGF3 : 4.933 Hz
   ITP4 : 0.365 Hz
   ITS4 : 0.317 Hz
   SOM4 : 0.704 Hz
   PV4 : 0.890 Hz
   VIP4 : 6.252 Hz
   NGF4 : 6.026 Hz
   IT5A : 0.752 Hz
   CT5A : 0.167 Hz
   SOM5A : 2.976 Hz
   PV5A : 0.284 Hz
   VIP5A : 1.111 Hz
   NGF5A : 3.818 Hz
   IT5B : 2.140 Hz
   CT5B : 0.173 Hz
   PT5B : 0.056 Hz
   SOM5B : 17.787 Hz
   PV5B : 0.116 Hz
   VIP5B : 0.847 Hz
   NGF5B : 3.102 Hz
   IT6 : 0.500 Hz
   CT6 : 0.355 Hz
   SOM6 : 8.644 Hz
   PV6 : 90.089 Hz
   VIP6 : 93.479 Hz
   NGF6 : 25.187 Hz
   TC : 5.824 Hz
   TCM : 4.173 Hz
   HTC : 5.184 Hz
   IRE : 3.599 Hz
   IREM : 2.785 Hz
   TI : 1.760 Hz
   TIM : 3.078 Hz
   IC : 3.701 Hz

python -i simdat.py 23nov3_BBN_B0

NGF1 1.55 Hz
IT2 0.13 Hz
SOM2 3.05 Hz
PV2 2.15 Hz
VIP2 20.96 Hz
NGF2 7.66 Hz
IT3 0.16 Hz
SOM3 1.8 Hz
PV3 5.17 Hz
VIP3 11.17 Hz
NGF3 4.94 Hz
ITP4 0.37 Hz
ITS4 0.32 Hz
SOM4 0.69 Hz
PV4 0.9 Hz
VIP4 6.28 Hz
NGF4 6.16 Hz
IT5A 0.64 Hz
CT5A 0.08 Hz
SOM5A 2.95 Hz
PV5A 0.27 Hz
VIP5A 0.81 Hz
NGF5A 3.6 Hz
IT5B 2.14 Hz
CT5B 0.17 Hz
PT5B 0.05 Hz
SOM5B 17.64 Hz
PV5B 0.1 Hz
VIP5B 0.6 Hz
NGF5B 2.95 Hz
IT6 0.46 Hz
CT6 0.31 Hz
SOM6 8.37 Hz
PV6 90.82 Hz
VIP6 87.36 Hz
NGF6 25.13 Hz
TC 5.68 Hz
TCM 4.15 Hz
HTC 5.05 Hz
IRE 3.57 Hz
IREM 2.74 Hz
TI 1.76 Hz
TIM 3.07 Hz
IC 3.69 Hz

drawraster(dspkT,dspkID)
savefig(gifpath()+'_rast.png') # [[./gif/23nov3_23nov3_BBN_B0_rast.png]]

looks better - can see clear time-locked response in L2/3 and L4

xlim((4e3,6e3))
savefig(gifpath()+'_rastB.png') # [[./gif/23nov3_23nov3_BBN_B0_rastB.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, 11e3) for k in dnumc.keys()}

lkectx = ['IT2', 'IT3', 'ITP4', 'ITS4']
lkictx = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)

lk = ['NGF1', 'SOM2', 'PV2', 'VIP2', 'NGF2', 'SOM3', 'PV3', 'VIP3', 'NGF3', 'SOM4', 'PV4', 'VIP4', 'NGF4']

llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

savefig(gifpath()+'_spikehistE.png') # [[./gif/23nov3_23nov3_BBN_B0_spikehistE.png]]

subplot(3,1,2); ylim((0,1)); subplot(3,1,3); ylim((1,10))

savefig(gifpath()+'_spikehistF.png') # [[./gif/23nov3_23nov3_BBN_B0_spikehistF.png]]

lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, 11e3)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, 11e3)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,11e3))

subplot(3,1,2); ylim((0,2)); subplot(3,1,3); ylim((0,10))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov3_23nov3_BBN_B0_spikehistG.png]]

LFP = simConfig['simData']['LFP']
LFP = np.array(LFP)
tt = linspace(0,totalDur,LFP.shape[0])
CSD = getCSD(LFP, 1e3/0.05)
CSD.shape # (18, 220000)

lchan = [4, 10, 15]

for chan,clr in zip(lchan,['r','g','b']): plot(tt,CSD[chan,:],clr)

ylim((-30,30))
xlim((2e3,totalDur))

savefig(gifpath()+'_CSD_a4.png') # [[./gif/23nov3_23nov3_BBN_B0_CSD_a4.png]]

bbnT = np.arange(4000, 8000, 300)

from erp import *
dt = 0.05
sampr = 1e3/dt
bbnTrigIdx = [ms2index(x,sampr) for x in bbnT]
ttERP,avgERP = getAvgERP(CSD, sampr, bbnTrigIdx, 0, 150)

for chan,clr in zip(lchan,['r','g','b']): plot(ttERP,avgERP[chan,:],clr)

xlabel('Time (ms)');
xlim((0,150))
savefig(gifpath()+'_model_BBN_avg_ERP_CSD_a5.png') # [[./gif/23nov3_23nov3_BBN_B0_model_BBN_avg_ERP_CSD_a5.png]]

CSD ERPs have a clearer shape, but not sure in right direction ...

subplot(1,2,1)
drawcellVm(simConfig,ldrawpop=['ITP4','ITS4']) # 
subplot(1,2,2)
drawcellVm(simConfig,ldrawpop=['PV4','SOM4','NGF4']) # 

savefig(gifpath()+'_cell_Vm_a6.png') # [[./gif/23nov3_23nov3_BBN_B0_cell_Vm_a6.png]]

not all L4 cells firing now, but as population there's a clear response...

may need to optimize for ERP CSD since polarity could be reversed

* 23nov6
** continue with latest simulation

check overall CSD ERP

since even if waveforms look incorrect on channels, used, nearby channels could
have better-looking waveforms ... 

look in analysis/plostCSD.py for some useful functions

from matplotlib import pyplot as plt
from netpyne import sim

fn = 'data/23nov3_BBN_B0/23nov3_BBN_B0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': 100, 'L2': 160, 'L3': 950, 'L4': 1250, 'L5A': 1334, 'L5B': 1550, 'L6': 2000}
sim.analysis.plotCSD(overlay='LFP',timeRange=[3.5e3,8.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD_a0.png') # [[./gif/23nov6_23nov3_BBN_B0_CSD_a0.png]]

can see sinks/sources, but looks like main sink is above L4 (somewhere in L3), while main
source is in L4 ... well some sinks in L4, but not as prominent ... 

savefig(gifpath()+'_CSD_a1.png') # [[./gif/23nov6_23nov3_BBN_B0_CSD_a1.png]]

sim.analysis.plotCSD(overlay='CSD',timeRange=[3.5e3,8.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/23nov6_23nov3_BBN_B0_CSD_CSD_overlay_a2.png]]

savefig(gifpath()+'_CSD__CSD_overlay_a3.png') # [[./gif/23nov6_23nov3_BBN_B0_CSD_CSD_overlay_a3.png]]

** email about CSD

I made some of those modifications to the model (adjusting level of
activation between IC->Thalamic core vs matrix, and Thal->Ctx
excitatory vs Thal->Ctx interneurons), ... now we get a more
pronounced response in L4 after BBN stimulation (between 4-8 s in the
model, every 300 ms).

In the attached figures there's a rasterplot and CSD.

Does the CSD look somewhat realistic / similar to what you see in BBN experiments? 

There are prominent sinks during BBN, but slightly above the model's L4 (more in L3).

Perhaps it's OK to use the ~L3 location as the approximate granular
sink for purposes of optimization?

Let me know if anything else stands out.

attachments:
  [[./gif/23nov3_23nov3_BBN_B0_rast.png]]  
  [[./gif/23nov6_23nov3_BBN_B0_CSD_CSD_overlay_a2.png]]
  [[./gif/23nov6_23nov3_BBN_B0_CSD_CSD_overlay_a3.png]]

no> Is the first plot the response to BBN and the 2nd to the 40Hz stimuli?

I don't know Sam….Annie and I discussed it and we don't think these
CSD responses look correct. There should not be a source in the
granular layer (unless it's an inhibitory response) and the response
in the upper supra should not have such a low amplitude
either. Generally the CSD response amplitude in the upper and lower
Supra layer should be pretty equal. Sorry!

And in the 40HZ response similarly there should be an initial sink
in the granular layer.
 
You probably told me this already but what BF do you have this cortical
column tuned to?

sn> Both images I attached are responses to BBN at 300 ms intervals
(from 4-8 s), none of those images had 40 Hz inputs. One was a raster
plot, the other CSD. The BF is similar to NHP recordings.

Thanks for the feedback.

I'm thinking that the location of sinks/sources has more to do with
the location of E vs I synapses on the dendrites, so the only way to
move sinks/sources to physiological locations is to adjust that entire
setup, which is a big change to the model. Alternatively, there's a
chance that adjusting the relative input strengths of E vs I synapses
while keeping them fixed vertically would work. . .

jc> sorry, to clarify for me, does adjusting relative input strengths
meaning altering the synaptic weights while retaining the same overall
activity?

samn> good question. remains to be seen. we'd probably want about same
spontaneous firing rates, but allow for higher rates during auditory
stimulation.  hopefully strength adjustments enough...seems feasible
given ITS4 should have enough AMPA/NMDA activation within L4

** more adjustments -- need stronger excitatory activation within L4 to produce current sink there

try simple test of increasing cfg.thalL4E from 1.0 to 2.0
and thalL4PV and thalL4SOM from 0.5 to 0.25

also, no need for 11 s simulation ... just run BBN stimulation for 1 s (3-4 s) and then stop simulation after ~7 s
should be enough to look at basic BBN response

./myrun 48

   NGF1 : 1.286 Hz
   IT2 : 0.877 Hz
   SOM2 : 5.171 Hz
   PV2 : 23.549 Hz
   VIP2 : 11.652 Hz
   NGF2 : 18.086 Hz
   IT3 : 0.171 Hz
   SOM3 : 5.884 Hz
   PV3 : 30.593 Hz
   VIP3 : 59.826 Hz
   NGF3 : 8.314 Hz
   ITP4 : 2.429 Hz
   ITS4 : 2.134 Hz
   SOM4 : 17.975 Hz
   PV4 : 6.845 Hz
   VIP4 : 25.857 Hz
   NGF4 : 14.643 Hz
   IT5A : 1.740 Hz
   CT5A : 2.495 Hz
   SOM5A : 14.259 Hz
   PV5A : 4.226 Hz
   VIP5A : 22.794 Hz
   NGF5A : 22.768 Hz
   IT5B : 7.964 Hz
   CT5B : 1.682 Hz
   PT5B : 0.177 Hz
   SOM5B : 32.493 Hz
   PV5B : 1.106 Hz
   VIP5B : 10.786 Hz
   NGF5B : 19.482 Hz
   IT6 : 3.109 Hz
   CT6 : 2.903 Hz
   SOM6 : 82.354 Hz
   PV6 : 0.098 Hz
   VIP6 : 2.753 Hz
   NGF6 : 188.086 Hz
   TC : 8.578 Hz
   TCM : 6.191 Hz
   HTC : 7.274 Hz
   IRE : 3.914 Hz
   IREM : 3.320 Hz
   TI : 2.297 Hz
   TIM : 2.946 Hz
   IC : 1.662 Hz

python -i simdat.py 23nov6_BBN_A0

NGF1 1.35 Hz
IT2 0.32 Hz
SOM2 3.6 Hz
PV2 7.08 Hz
VIP2 1.0 Hz
NGF2 19.91 Hz
IT3 0.0 Hz
SOM3 0.04 Hz
PV3 33.25 Hz
VIP3 67.38 Hz
NGF3 7.83 Hz
ITP4 2.74 Hz
ITS4 2.49 Hz
SOM4 25.33 Hz
PV4 3.89 Hz
VIP4 2.23 Hz
NGF4 14.21 Hz
IT5A 1.31 Hz
CT5A 1.64 Hz
SOM5A 9.65 Hz
PV5A 6.11 Hz
VIP5A 47.5 Hz
NGF5A 26.5 Hz
IT5B 8.22 Hz
CT5B 0.73 Hz
PT5B 0.15 Hz
SOM5B 23.97 Hz
PV5B 0.89 Hz
VIP5B 20.82 Hz
NGF5B 24.92 Hz
IT6 1.69 Hz
CT6 2.67 Hz
SOM6 76.98 Hz
PV6 0.0 Hz
VIP6 0.0 Hz
NGF6 175.39 Hz
TC 6.95 Hz
TCM 6.55 Hz
HTC 6.42 Hz
IRE 3.35 Hz
IREM 3.39 Hz
TI 2.29 Hz
TIM 2.98 Hz
IC 0.0 Hz

savefig(gifpath()+'_rast.png') # [[./gif/23nov6_23nov6_BBN_A0_rast.png]]

sh = {k:getspikehist(dspkT[k], dnumc[k], 25, totalDur) for k in dnumc.keys()}
lkictx = ['SOM4', 'PV4', 'VIP4', 'NGF4']
lkectx = ['ITP4', 'ITS4']
sh['ECTX'] = getspikehistpops(dspkT, lkectx, dnumc, 25, totalDur)
sh['ICTX'] = getspikehistpops(dspkT, lkictx, dnumc, 25, totalDur)
lk = ['SOM4', 'PV4', 'VIP4', 'NGF4']
llk = [ ['IC', 'TC', 'TCM'], ['ECTX'], ['ICTX']]
llclr = [['r','g','b'], ['r'], ['b']]

for lk,lclr,gdx in zip(llk, llclr,[1,2,3]): 
  ax=subplot(3,1,gdx)
  for k,clr in zip(lk,lclr):
    plot(sh[k][0],sh[k][1],clr); xlabel('Time (ms)'); ylabel('Hz')
  lpatch = [mpatches.Patch(color=c,label=s) for c,s in zip(lclr,lk)]
  ax.legend(handles=lpatch,handlelength=1)
  xlim((0,totalDur))

subplot(3,1,2); ylim((0,10)); subplot(3,1,3); ylim((0,25))

savefig(gifpath()+'_spikehistG.png') # [[./gif/23nov6_23nov6_BBN_A0_spikehistG.png]]

python
from matplotlib import pyplot as plt
from netpyne import sim

fn = 'data/23nov6_BBN_A0/23nov6_BBN_A0_data.pkl'

sim.load(fn,instantiate=False) # should use this more often

layerBounds = {'L1': 100, 'L2': 160, 'L3': 950, 'L4': 1250, 'L5A': 1334, 'L5B': 1550, 'L6': 2000}
sim.analysis.plotCSD(overlay='CSD',timeRange=[2.75e3,4.5e3],stim_start_time=4e3,spacing_um=100,layerLines=True,layerBounds=layerBounds) # this works ...

savefig(gifpath()+'_CSD__CSD_overlay_a2.png') # [[./gif/23nov6_23nov6_BBN_A0_CSD_CSD_overlay_a2.png]]

** follow up email to no

well, I tweaked connection strength from thalamic core -> L4 E and I
neurons and got sinks in L4 during BBN ... firing activity is now too
high, so this will require some optimization to get right. At least it
shows that we can get ~the desired CSD profiles by tweaking some
parameters we have access to ...

attachments:
 [[./gif/23nov6_23nov6_BBN_A0_rast.png]]
 [[./gif/23nov6_23nov6_BBN_A0_CSD_CSD_overlay_a2.png]]

* 23nov7
** more discussion on CSD during BBN

CM That looks good! Will also run some more sims with increased
cfg.thalL4E and decreased cfg.thall4SOM,PV later 

Two quick comments:
The Allen Insitute paper Salva shared some days ago suggests that it
might be possible to shift the synapse locations (and thus change the
CSD) without a big effect on the firing rates (so maybe not that big
of a change to the model!?). It also suggests that CSD patterns in
supragranular layers might depend on feedback from higher areas. which
we could artificially inject during stimulation (not the most elegant
way of doing it but maybe the quickest) and thus we would also not
alter the spontaneous activity

samn: That sounds interesting to try, though synapses were placed on
the neurons based on known physiology/anatomy, so not sure we should
do that only to avoid re-tuning the model.

@salvadord
 what do you think?

top-down inputs another question ... we might get part of that effect
through thalamic matrix, but have to see if that top-down input should
be primarily cortical/excitatory ...
 
 cm I believe in the Allen paper it was primarily ecitatory  but will have to reread the paper

cm: I agree it would be a big change if we significantly moved away
from the experimental data.It might however be possible to first
change the weights as you suggested earlier and then potentially move
the synapses a little bit or change the percentage of synapses that go
onto a specific compartment slightly (let's say within experimental
variability), although I am not sure how much that would give us
because of the reduced morphology

samn: agree with that assessment. and agree that for cells such as ITS4
which are already compact/very simplified geometries, likely won't
have much room to move their synapses.

sd: to be fair I don’t think we had that much detailed data on the
dendritic placement of syns, particularly specific to macaque A1 …
plus the cells are just 5 compartments, so I don’t think the changes
should affect the spiking activity that significantly, and
particularly since we have weight normalization/democratization
(weights are adjusted so they produce similar effect on soma) … but
the changes might still affect the LFP/EEG significantly, so I think
it is worth trying

samn: i wasn't clear how much the synapses could move since they'll
still be localized within the boundaries of the cells, which are small
for ITS4. but agree it's worth a try & might help in other layers -
anyone here want to try that? i'll probably start with weight
adjustments

** email from no

This is does look better alright for the gran layer but the pattern of
sinks and sources in the supra layer is still off (it should be source
over a sink). Perhaps that will come with further modifications.

sn> great ... !

for correct patterns in supra-granular layers, a question came up
whether it will require: 1) additional top-down cortico-cortical
feedback, or 2) depends on either local cortical circuitry within A1
(L4 -> L2/3 pathway), or 3) from thalamic projections (matrix ->
L2/3)... we can likely achieve the right effect with any of these
modifications, but would prefer to stick to the correct neuroanatomy,
where possible ...

** avg ERP data at 20 kHz for optimization (on edge)

/home/samn/a1dat/data/bbn/avgERP/2-rb023024011@os.mat_20kHz_avgERP.pkl
/home/samn/a1dat/data/bbn/avgERP/2-rb023024052@os.mat_20kHz_avgERP.pkl

** install optuna 

pip install optuna
conda install sqlalchemy

apparently need sqlalchemy for optuna to import properly ...

python
import optuna

python
import netpyne
dir(netpyne.batch)
['Batch', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'absolute_import', 'asd_parallel', 'batch', 'division', 'evol', 'grid', 'optuna_parallel', 'print_function', 'standard_library', 'unicode_literals', 'utils']

now optuna visible in netpyne.batch

** back to opt setup

for now will just take correlation between avg granular CSD ERP
fitness is 'minimized', so will take -pearson correlation

python batch.py
Saving batch to data/optunaERP/optunaERP_batch.json ... 
 Warning: an exception occurred when running Optuna optimization...

mpiexec -np 2 nrniv -python -mpi batch.py

 mpiexec -np 2 nrniv -python -mpi batch.py
numprocs=2
NEURON -- VERSION 8.0.2 HEAD (f0ca7454) 2022-02-02
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2021
See http://neuron.yale.edu/neuron/credits

Additional mechanisms from files
 "mod/APCounter2.mod" "mod/ar_traub.mod" "mod/beforestep_py.mod" "mod/CA1ika.mod" "mod/CA1ikdr.mod" "mod/CA1ina.mod" "mod/cadad.mod" "mod/cadecay_destexhe.mod" "mod/cad.mod" "mod/Cadynamics.mod" "mod/cadyn.mod" "mod/cagk.mod" "mod/cal_mh.mod" "mod/cal_mig.mod" "mod/cancr.mod" "mod/canin.mod" "mod/can_mig.mod" "mod/caolmw.mod" "mod/capr.mod" "mod/catcb.mod" "mod/cat_mig.mod" "mod/cat_traub.mod" "mod/ch_CavL.mod" "mod/ch_CavN.mod" "mod/ch_KCaS.mod" "mod/ch_Kdrfastngf.mod" "mod/ch_KvAngf.mod" "mod/ch_KvCaB.mod" "mod/ch_leak.mod" "mod/ch_Navngf.mod" "mod/cp2.mod" "mod/cp.mod" "mod/DynamicNetStim.mod" "mod/gabab.mod" "mod/h_BS.mod" "mod/HH2.mod" "mod/h_harnett.mod" "mod/HH_traub.mod" "mod/hin.mod" "mod/h_kole.mod" "mod/h_migliore.mod" "mod/htc.mod" "mod/Iahp.mod" "mod/ICal.mod" "mod/Ican.mod" "mod/ican_sidi.mod" "mod/icaolmw.mod" "mod/icapr.mod" "mod/iccr.mod" "mod/IC.mod" "mod/iconc_Ca.mod" "mod/iholmkop.mod" "mod/iholmw.mod" "mod/ihpyrkop.mod" "mod/IKM.mod" "mod/ikscr.mod" "mod/IKsin.mod" "mod/IL_gutnick.mod" "mod/IL.mod" "mod/IM_cortex.mod" "mod/ipulse3.mod" "mod/IT2.mod" "mod/IT.mod" "mod/kahppr.mod" "mod/kaolmkop.mod" "mod/kap_BS.mod" "mod/kapcb.mod" "mod/kapin.mod" "mod/kapyrkop.mod" "mod/kBK.mod" "mod/kca.mod" "mod/kcaolmw.mod" "mod/kcpr.mod" "mod/kctin.mod" "mod/kdmc_BS.mod" "mod/kdr2_orig.mod" "mod/kdr_BS.mod" "mod/kdrbwb.mod" "mod/kdrcr.mod" "mod/kdrin.mod" "mod/kdrolmkop.mod" "mod/kdrpr.mod" "mod/kdrpyrkop.mod" "mod/kl.mod" "mod/km.mod" "mod/kv.mod" "mod/MyExp2SynAlpha.mod" "mod/MyExp2SynBB.mod" "mod/my_exp2syn.mod" "mod/MyExp2SynNMDABB.mod" "mod/na_2.mod" "mod/naf2.mod" "mod/nafbwb.mod" "mod/nafcr.mod" "mod/nafolmkop.mod" "mod/nafpr.mod" "mod/nafpyrkop.mod" "mod/nafx.mod" "mod/nap_sidi.mod" "mod/nax_BS.mod" "mod/naz.mod" "mod/Nca.mod" "mod/ntIh.mod" "mod/ntleak.mod" "mod/ntt_int.mod" "mod/ntt.mod" "mod/pasi.mod" "mod/savedist.mod" "mod/tia.mod" "mod/vecstim.mod" "mod/wrap.mod"
bash: /opt/miniconda3/envs/py376/lib/libtinfo.so.6: no version information available (required by bash)
running batch...
Saving batch to data/optunaERP/optunaERP_batch.json ... 
 Warning: an exception occurred when running Optuna optimization...
>>> 
running batch...
Saving batch to data/optunaERP/optunaERP_batch.json ... 
 Warning: an exception occurred when running Optuna optimization...

debugging ...

* 23nov8
** continue setup for optuna ERP

apparently, this is a problem:
    params[('seeds', 'conn')] = [0]
    params[('seeds', 'stim')] = [0]

since when get rid of it, both optuna and evol seem to run ... 

also, need to make sure optuna, inspyred, sqlalchemy packages are installed
in order to use optuna or inspyred with netpyne

